<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <meta name="theme-color" content="#050505" />
  <link rel="icon" type="image/png" sizes="64x64" href="/favicon.png">
  <title>系统监控</title>
  <link rel="manifest" href="manifest.json" />
  <link href="css/inter.css" rel="stylesheet">
  <link href="css/remixicon.css" rel="stylesheet">
  <style>
    :root {
      --bg: #050505;
      --card-bg: rgba(20, 30, 45, 0.6);
      --card-border: rgba(255, 255, 255, 0.08);
      --text-main: #ffffff;
      --text-muted: #94a3b8;
      --accent-primary: #00f2ff;
      --accent-secondary: #ff8c00;
      --accent-tertiary: #00e676;
      --glass-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.36);
      --grid-line: rgba(255, 255, 255, 0.06);
      --chip-bg: rgba(255, 255, 255, 0.05);
      --good: #00e676;
      --warn: #ffea00;
      --bad: #ff1744;
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0;
      font-family: 'Inter', system-ui, -apple-system, sans-serif;
      background: radial-gradient(circle at 50% 0%, #1a2c4e, var(--bg) 80%);
      color: var(--text-main);
      overflow: hidden;
    }
    .app {
      height: 100vh;
      overflow-y: auto;
      padding: 24px;
      display: flex;
      flex-direction: column;
      gap: 24px;
      scrollbar-width: thin;
      scrollbar-color: var(--accent-primary) transparent;
      max-width: 1600px;
      margin: 0 auto;
    }
    .app::-webkit-scrollbar { width: 8px; }
    .app::-webkit-scrollbar-track { background: transparent; }
    .app::-webkit-scrollbar-thumb {
      background: var(--accent-primary);
      border-radius: 99px;
    }
    
    /* Header */
    header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 16px 24px;
      background: rgba(255, 255, 255, 0.03);
      border: 1px solid var(--card-border);
      border-radius: 24px;
      backdrop-filter: blur(16px);
      position: sticky;
      top: 0;
      z-index: 10;
      box-shadow: var(--glass-shadow);
    }
    .title { font-weight: 700; font-size: 18px; letter-spacing: -0.5px; }
    .subtitle { color: var(--text-muted); font-size: 13px; font-weight: 500; }

    /* Grid */
    .content { flex: 1 0 auto; display: flex; gap: 24px; }
    .grid {
      flex: 1;
      display: grid;
      gap: 24px;
      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
      align-content: start;
      grid-auto-flow: dense;
    }
    
    /* Cards */
    .card {
      background: linear-gradient(135deg, rgba(255,255,255,0.05), rgba(255,255,255,0.01));
      border: 1px solid var(--card-border);
      border-radius: 24px;
      padding: 24px;
      display: flex;
      flex-direction: column;
      gap: 16px;
      box-shadow: var(--glass-shadow);
      backdrop-filter: blur(12px);
      transition: transform 0.3s ease, border-color 0.3s ease;
      position: relative;
      overflow: hidden;
      --rx: -1000px;
      --ry: -1000px;
      --light-rgb: 255, 255, 255;
      --light-size: 600px;
    }
    .card::before {
      content: "";
      position: absolute;
      inset: 0;
      border-radius: 24px;
      padding: 1.5px;
      background: radial-gradient(
        var(--light-size) circle at var(--rx) var(--ry), 
        rgba(var(--light-rgb), 0.6),
        rgba(var(--light-rgb), 0.1) 40%,
        transparent 80%
      );
      -webkit-mask: 
        linear-gradient(#fff 0 0) content-box, 
        linear-gradient(#fff 0 0);
      -webkit-mask-composite: xor;
      mask-composite: exclude;
      pointer-events: none;
      opacity: var(--light-intensity, 1);
      transition: opacity 0.5s;
    }
    .card::after {
      content: "";
      position: absolute;
      inset: 0;
      border-radius: 24px;
      background: radial-gradient(
        calc(var(--light-size) * 1.5) circle at var(--rx) var(--ry), 
        rgba(var(--light-rgb), 0.08),
        transparent 60%
      );
      pointer-events: none;
      opacity: var(--light-intensity, 1);
    }
    .card:hover {
      transform: translateY(-4px);
      border-color: rgba(255, 255, 255, 0.15);
    }
    .card.span-2 { grid-column: span 2; }

    /* Typography & Components */
    .row { display: flex; align-items: flex-start; gap: 16px; }
    .grow { flex: 1; min-width: 0; }
    .label { color: var(--text-muted); font-size: 12px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; line-height: 1.5; }
    .value { font-weight: 700; font-size: 28px; letter-spacing: -1px; line-height: 1.2; }
    .unit { font-size: 14px; opacity: 0.7; font-weight: 500; }
    .mono { font-family: 'Inter', monospace; font-variant-numeric: tabular-nums; }
    
    /* Icons */
    .icon {
      width: 48px; height: 48px;
      background: rgba(255,255,255,0.03);
      border: 1px solid var(--card-border);
      border-radius: 12px;
      display: grid; place-items: center;
      flex-shrink: 0;
      font-size: 24px;
      color: var(--accent-primary);
      opacity: 0.9;
    }
    
    /* Chips */
    .chip {
      display: inline-flex; align-items: center; gap: 8px;
      padding: 6px 12px;
      border-radius: 99px;
      background: var(--chip-bg);
      border: 1px solid var(--card-border);
      font-size: 13px;
      color: var(--text-main);
    }
    .chip.small { font-size: 12px; padding: 4px 10px; }
    .chip-row { display: flex; flex-wrap: wrap; gap: 8px; margin-top: 4px; }
    .chip-label { color: var(--text-muted); margin-right: 4px; }
    .chip-value { font-weight: 600; }
    .chip.good { background: rgba(0, 230, 118, 0.1); border-color: rgba(0, 230, 118, 0.3); color: var(--good); }
    .chip.warn { background: rgba(255, 234, 0, 0.1); border-color: rgba(255, 234, 0, 0.3); color: var(--warn); }
    .chip.bad { background: rgba(255, 23, 68, 0.1); border-color: rgba(255, 23, 68, 0.3); color: var(--bad); }

    /* Rings & Meters */
    .ring {
      --p: 0; --col: var(--accent-primary);
      width: 80px; height: 80px;
      border-radius: 50%;
      position: relative;
      background: conic-gradient(var(--col) calc(var(--p)*1%), rgba(255,255,255,0.05) 0);
      display: grid; place-items: center;
      flex-shrink: 0;
      box-shadow: 0 0 20px rgba(0,0,0,0.2);
      align-self: center;
    }
    .ring::before {
      content: ""; position: absolute; inset: 8px;
      background: #131b29; /* Darker inner circle to simulate hole */
      border-radius: 50%;
    }
    .ring span { position: relative; font-weight: 700; font-size: 18px; }

    .meter {
      height: 8px;
      background: rgba(255,255,255,0.05);
      border-radius: 99px;
      overflow: hidden;
    }
    .meter > i {
      display: block; height: 100%; width: 0;
      background: var(--accent-primary);
      transition: width 0.5s cubic-bezier(0.4, 0, 0.2, 1);
      box-shadow: 0 0 10px var(--accent-primary);
    }

    .kv { display: grid; grid-template-columns: auto 1fr auto; gap: 8px 16px; align-items: center; font-size: 13px; }
    
    /* Canvas */
    canvas.spark {
      width: 100%; height: 64px;
      background: rgba(0,0,0,0.2);
      border-radius: 16px;
      border: 1px solid var(--card-border);
      margin-top: auto;
      display: block;
    }

    /* Footer */
    footer {
      display: flex; justify-content: space-between; align-items: center;
      color: var(--text-muted); font-size: 12px;
      padding: 0 12px;
    }

    /* Specific Components */
    .gpu-button {
      width: 28px; height: 28px;
      border-radius: 8px;
      border: 1px solid var(--card-border);
      background: rgba(255,255,255,0.05);
      color: var(--text-main);
      display: grid; place-items: center;
      cursor: pointer;
      transition: all 0.2s;
    }
    .gpu-button:hover:not(:disabled) {
      background: var(--accent-primary);
      color: #000;
      box-shadow: 0 0 12px var(--accent-primary);
    }
    .gpu-button:disabled { opacity: 0.3; cursor: not-allowed; }
    
    .gpu-name-switch { display: flex; align-items: center; gap: 8px; margin-top: 4px; }
    .gpu-ring-wrap { width: 80px; height: 80px; display: flex; align-items: center; justify-content: center; flex-shrink: 0; }
    .gpu-ring-wrap .ring { width: 80px; height: 80px; }
    
    /* Marquee */
    .name-chip { max-width: 180px; overflow: hidden; white-space: nowrap; min-width: 0; }
    .name-chip.marquee { position: relative; }
    .name-chip.marquee .marquee-track { display: inline-flex; animation: marquee 10s linear infinite; }
    .name-chip.marquee .marquee-track span { padding-right: 24px; }
    @keyframes marquee { 0% { transform: translateX(0); } 100% { transform: translateX(-50%); } }
    
    /* Foreground app title marquee */
    .title-text {
      font-size: 18px;
      font-weight: 700;
      overflow: hidden;
      text-overflow: ellipsis;
      display: -webkit-box;
      -webkit-box-orient: vertical;
      -webkit-line-clamp: 2;
      line-clamp: 2;
      white-space: normal;
      word-break: break-word;
    }
    .title-text.marquee { position: relative; }
    .title-text.marquee .marquee-track { display: inline-flex; white-space: nowrap; animation: marquee 10s linear infinite; }
    .title-text.marquee .marquee-track span { padding-right: 32px; }
    #fg-top-list { min-width: 0; }
    #fg-top-list .chip { max-width: 100%; min-width: 0; }
    #fg-top-list .fg-chip-name { flex: 1; min-width: 0; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }

    /* Temp Card */
    .temp-card {
      --temp-card-base-height: 140px;
      min-height: var(--temp-card-base-height);
      transition: min-height 0.4s cubic-bezier(0.4, 0, 0.2, 1);
    }
    .temp-card.expanded { min-height: calc(var(--temp-card-base-height) * 2); }
    .temp-card .temp-header { display: flex; justify-content: space-between; align-items: flex-start; gap: 12px; }
    .temp-highlights { display: flex; gap: 8px; flex-wrap: wrap; margin-top: 6px; }
    
    .temp-toggle {
      background: rgba(255,255,255,0.05);
      border: 1px solid var(--card-border);
      color: var(--text-main);
      padding: 6px 12px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 12px;
      transition: all 0.2s;
    }
    .temp-toggle:hover { background: rgba(255,255,255,0.1); }
    
    .temp-chip {
      background: linear-gradient(135deg, rgba(0, 242, 255, 0.1), rgba(0,0,0,0));
      border: 1px solid rgba(0, 242, 255, 0.2);
      border-radius: 16px;
      padding: 12px;
      min-width: 100px;
      display: flex; flex-direction: column; gap: 4px;
    }
    .temp-chip .label { font-size: 11px; color: var(--text-muted); }
    .temp-chip .value { font-size: 18px; font-weight: 600; }
    
    .temp-list-wrapper {
      margin-top: 16px;
      background: rgba(0,0,0,0.2);
      border-radius: 16px;
      overflow: hidden;
      max-height: 0;
      transition: max-height 0.4s ease;
    }
    .temp-card.expanded .temp-list-wrapper { max-height: 400px; }
    .temp-list { padding: 12px; margin: 0; list-style: none; display: flex; flex-direction: column; gap: 8px; overflow-y: auto; max-height: 380px; }
    .temp-item {
      display: flex; justify-content: space-between;
      padding: 8px 12px;
      background: rgba(255,255,255,0.03);
      border-radius: 8px;
      font-size: 13px;
      border: 1px solid var(--card-border);
    }
    
    /* Mini Temp Grid */
    .temp-mini-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); gap: 8px; margin-top: 10px; }
    .temp-card.expanded .temp-mini-grid { display: none; }
    .mini-chip {
      display: flex; flex-direction: column; gap: 6px;
      padding: 8px 10px; border-radius: 10px;
      background: rgba(255,255,255,0.04);
      border: 1px solid var(--card-border);
      min-width: 0;
    }
    .mini-chip .label { font-size: 11px; color: var(--text-muted); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .mini-chip .value { font-size: 16px; font-weight: 700; }
    .mini-chip.good { background: rgba(0, 230, 118, 0.1); border-color: rgba(0, 230, 118, 0.3); }
    .mini-chip.warn { background: rgba(255, 234, 0, 0.1); border-color: rgba(255, 234, 0, 0.3); }
    .mini-chip.bad { background: rgba(255, 23, 68, 0.1); border-color: rgba(255, 23, 68, 0.3); }
    .mini-bar { height: 6px; border-radius: 999px; background: rgba(255,255,255,0.1); overflow: hidden; }
    .mini-bar > i { display: block; height: 100%; width: 40%; background: linear-gradient(90deg, #58a6ff, #ff8a65); }

    /* Responsive */
    @media (max-width: 1100px) {
      .grid { grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); }
      .content { flex-direction: column; }
      .panel-card { flex: 1; min-height: auto; }
    }
    @media (max-width: 768px) {
      .app { padding: 16px; gap: 16px; }
      .grid { grid-template-columns: 1fr; }
      .card.span-2 { grid-column: span 1; }
      .row { flex-wrap: wrap; }
    }

    /* Modal */
    .modal-overlay {
      position: fixed; inset: 0;
      background: rgba(0,0,0,0.6);
      backdrop-filter: blur(4px);
      z-index: 100;
      display: none;
      place-items: center;
      opacity: 0;
      transition: opacity 0.3s;
    }
    .modal-overlay.open { display: grid; opacity: 1; }
    .modal {
      background: #131b29;
      border: 1px solid var(--card-border);
      border-radius: 24px;
      padding: 24px;
      width: 90%; max-width: 400px;
      box-shadow: var(--glass-shadow);
      transform: scale(0.9);
      transition: transform 0.3s;
    }
    .modal-overlay.open .modal { transform: scale(1); }
    .modal-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px; }
    .modal-title { font-size: 18px; font-weight: 700; }
    .modal-close { background: none; border: none; color: var(--text-muted); cursor: pointer; font-size: 24px; }
    .modal-body { display: flex; flex-direction: column; gap: 16px; }
    .control-row { display: flex; justify-content: space-between; align-items: center; }
    .switch {
      position: relative; display: inline-block; width: 48px; height: 24px;
    }
    .switch input { opacity: 0; width: 0; height: 0; }
    .slider {
      position: absolute; cursor: pointer; inset: 0;
      background-color: rgba(255,255,255,0.1);
      border-radius: 24px; transition: .4s;
    }
    .slider:before {
      position: absolute; content: "";
      height: 18px; width: 18px; left: 3px; bottom: 3px;
      background-color: white; border-radius: 50%; transition: .4s;
    }
    input:checked + .slider { background-color: var(--accent-primary); }
    input:checked + .slider:before { transform: translateX(24px); }
    input:disabled + .slider { opacity: 0.5; cursor: not-allowed; }
  </style>
</head>
<body>
  <div class="app">
    <header>
      <div>
        <div class="title">系统监控</div>
        <div class="subtitle" id="host">—</div>
      </div>
      <button class="chip" id="clock" style="cursor:pointer; border:none; font-family:inherit; font-size:inherit; outline:none;">00:00:00</button>
    </header>

    <div class="content">
      <main class="grid">
        <section class="card span-2">
          <div class="card-content">
            <div class="row">
               <i class="ri-cpu-line icon"></i>
              <div class="grow">
                <div class="label">CPU</div>
                <div class="value mono" id="cpu-usage">0%</div>
                <div class="chip small name-chip cpu-name" id="cpu-name-chip"><span>—</span></div>
              </div>
              <div class="ring" id="cpu-ring"><span class="mono" id="cpu-ring-val">0%</span></div>
            </div>
            <div class="kv">
              <div class="label">温度</div><div class="meter"><i id="cpu-temp-bar"></i></div><div class="mono" id="cpu-temp">— ℃</div>
              <div class="label">频率</div><div class="meter"><i id="cpu-clock-bar"></i></div><div class="mono" id="cpu-clock">— MHz</div>
            </div>
          </div>
          <canvas class="spark" id="cpu-spark"></canvas>
        </section>

        <section class="card span-2" id="gpu-card">
          <div class="card-content">
            <div class="row">
              <i class="ri-dashboard-3-line icon"></i>
              <div class="grow">
                <div class="label">GPU</div>
                <div class="value mono" id="gpu-usage">0%</div>
                <div class="gpu-name-switch">
                  <button type="button" class="gpu-button prev" id="gpu-prev" aria-label="上一块 GPU">&#60;</button>
                  <div class="chip small name-chip gpu-name" id="gpu-name-chip"><span>—</span></div>
                  <button type="button" class="gpu-button next" id="gpu-next" aria-label="下一块 GPU">&#62;</button>
                </div>
              </div>
              <div class="gpu-ring-wrap">
                <div class="ring" id="gpu-ring" style="--col:var(--accent-secondary)"><span class="mono" id="gpu-ring-val">0%</span></div>
              </div>
            </div>
            <div class="kv">
              <div class="label">温度</div><div class="meter"><i id="gpu-temp-bar" style="background:linear-gradient(90deg,var(--accent-secondary),#ff8a65)"></i></div><div class="mono" id="gpu-temp">— ℃</div>
              <div class="label">频率</div><div class="meter"><i id="gpu-clock-bar" style="background:linear-gradient(90deg,var(--accent-secondary),#ff8a65)"></i></div><div class="mono" id="gpu-clock">— MHz</div>
              <div class="label">显存</div><div class="meter"><i id="gpu-memory-bar" style="background:linear-gradient(90deg,var(--accent-secondary),#ff8a65)"></i></div><div class="mono" id="gpu-memory">—</div>
            </div>
          </div>
          <canvas class="spark" id="gpu-spark"></canvas>
        </section>

        <section class="card">
          <div class="card-content">
            <div class="row">
              <div class="grow">
                <div class="label">内存概览</div>
                <div class="value mono"><span id="mem-used">--</span> / <span id="mem-total">--</span> <span class="unit">GB</span></div>
              </div>
              <div class="ring" id="mem-ring" style="--col:var(--accent-tertiary)"><span class="mono">0%</span></div>
            </div>
            <div class="chip-row">
              <div class="chip small" id="mem-speed-chip">
                <span class="chip-label">内存速度</span>
                <span class="chip-value mono" id="mem-speed">-- MHz</span>
              </div>
              <div class="chip small" id="mem-pressure-chip">
                <span class="chip-label">压力状态</span>
                <span class="chip-value mono" id="mem-pressure">--</span>
              </div>
            </div>
          </div>
          <canvas class="spark" id="mem-spark"></canvas>
        </section>

        <section class="card" id="fg-card">
          <div class="card-content">
            <div class="row">
              <div class="grow">
                <div class="label">前台应用</div>
                <div class="value title-text" id="fg-app-name">—</div>
                <div class="chip small" id="fg-process-name">—</div>
              </div>
            </div>
            <div class="kv">
              <div class="label">CPU</div><div class="meter"><i id="fg-cpu-bar"></i></div><div class="mono" id="fg-cpu">— %</div>
              <div class="label">内存</div><div class="meter"><i id="fg-mem-bar" style="background:linear-gradient(90deg,var(--accent-tertiary),#a5d66a)"></i></div><div class="mono" id="fg-mem">— MB</div>
            </div>
            <div class="chip-row" id="fg-top-list" style="margin-top:6px"></div>
          </div>
        </section>



        <section class="card">
          <div class="card-content">
            <div class="row">
              <div class="grow">
                <div class="label">网络</div>
                <div class="gpu-name-switch net-name-switch">
                  <button type="button" class="gpu-button prev" id="net-prev" aria-label="上一块网卡">&#60;</button>
                  <div class="chip small name-chip net-name" id="net-name-chip"><span>—</span></div>
                  <button type="button" class="gpu-button next" id="net-next" aria-label="下一块网卡">&#62;</button>
                </div>
                <div class="mono"  style="padding-top: 5px; padding-left: 10px;">↑ <span id="net-up">0.0</span> MB/s &nbsp; ↓ <span id="net-down">0.0</span> MB/s</div>
                <div class="chip-row" style="padding-top: 5px; padding-left: 6px; gap:6px">
                  <div class="chip small" id="net-link-chip"></div>
                </div>
                <div class="chip-row" style="padding-top: 5px; padding-left: 6px; gap:6px" id="net-ip-list"></div>
              </div>
            </div>
          </div>
          <canvas class="spark" id="net-spark"></canvas>
        </section>

        <section class="card">
          <div class="card-content">
            <div class="row">
              <div class="grow">
                <div class="label">磁盘 I/O</div>
                <div class="mono">R <span id="disk-r">0.0</span> MB/s &nbsp; W <span id="disk-w">0.0</span> MB/s</div>
                <div class="chip-row" style="margin-top:6px">
                  <div class="chip small" id="disk-total-chip">
                    <span class="chip-label">总吞吐</span>
                    <span class="chip-value mono" id="disk-total">0.0 MB/s</span>
                  </div>
                  <div class="chip small" id="disk-rw-chip">
                    <span class="chip-label">读/写占比</span>
                    <span class="chip-value mono" id="disk-rw-ratio">—</span>
                  </div>
                  <div class="chip small" id="disk-peak-chip">
                    <span class="chip-label">最近峰值</span>
                    <span class="chip-value mono" id="disk-peak">0.0 MB/s</span>
                  </div>
                </div>
                <div class="kv" style="margin-top:6px">
                  <div class="label">活跃度</div>
                  <div class="meter"><i id="disk-activity-bar"></i></div>
                  <div class="mono" id="disk-activity-text">— %</div>
                </div>
              </div>
            </div>
          </div>
          <canvas class="spark" id="disk-spark"></canvas>
        </section>



        <section class="card span-2 temp-card" id="temp-card">
          <div class="temp-header">
            <div>
              <div class="label">温度传感器</div>
              <div class="temp-highlights" id="temp-highlights">
                <div class="temp-chip">
                  <div class="label">CPU 封装</div>
                  <div class="value mono">—</div>
                </div>
                <div class="temp-chip">
                  <div class="label">CPU 核心</div>
                  <div class="value mono">—</div>
                </div>
                <div class="temp-chip">
                  <div class="label">主板</div>
                  <div class="value mono">—</div>
                </div>
              </div>
            </div>
            <button class="temp-toggle" id="temp-toggle">展开</button>
          </div>
          <!-- Top hottest sensors preview (collapsed only) -->
          <div class="temp-mini-grid" id="temp-mini-grid"></div>
          <div class="temp-list-wrapper">
            <ul class="temp-list" id="temp-list"></ul>
          </div>
        </section>
      </main>

      <!-- <aside class="alerts-panel" id="alerts-panel">
        <div class="panel-card">
          <div>
            <div class="panel-title">告警</div>
            <div class="panel-subtitle">实时监控</div>
          </div>
          <div class="alert-body" id="alert-list">
            <div class="alert-empty">当前无告警</div>
          </div>
        </div>
      </aside> -->
    </div>

    <footer>
      <div id="source" class="subtitle">数据源：LibreHardwareMonitor</div>
      <div class="mono" id="ver">—</div>
    </footer>
  </div>

  <!-- Settings Modal -->
  <div class="modal-overlay" id="settings-modal">
    <div class="modal">
      <div class="modal-header">
        <div class="modal-title">光效设置</div>
        <button class="modal-close" id="modal-close">&times;</button>
      </div>
      <div class="modal-body">
        <div class="control-row">
          <div class="label">自动变色</div>
          <label class="switch">
            <input type="checkbox" id="auto-color-toggle" checked>
            <span class="slider"></span>
          </label>
        </div>
        <div class="control-row">
          <div class="label">手动颜色</div>
          <input type="color" id="manual-color-picker" value="#00f2ff" disabled style="background:none; border:none; width:40px; height:40px; cursor:pointer;">
        </div>
        <div class="control-row">
          <div class="label">光照强度</div>
          <input type="range" id="intensity-slider" min="0" max="2" step="0.1" value="1" style="width: 120px; cursor: pointer;">
        </div>
      </div>
    </div>
  </div>

  <script>
    const $ = (s)=>document.querySelector(s);
    const setText = (id, v)=>{ const el=$(id); if(el) el.textContent = v };
    function clamp(n,min,max){ return Math.max(min, Math.min(max, n)) }
    function hexToRgba(hex, alpha) {
      const r = parseInt(hex.slice(1, 3), 16);
      const g = parseInt(hex.slice(3, 5), 16);
      const b = parseInt(hex.slice(5, 7), 16);
      return `rgba(${r}, ${g}, ${b}, ${alpha})`;
    }

    class Spark{
      constructor(canvas, capacity=120, yMaxHint=100, color='#00f2ff'){
        this.c = canvas; this.ctx = canvas.getContext('2d');
        this.buf = []; this.capacity = capacity; this.yMaxHint = yMaxHint;
        this.color = color;
        const dpr = Math.max(1, window.devicePixelRatio||1);
        const rect = this.c.getBoundingClientRect();
        this.c.width = rect.width * dpr; this.c.height = rect.height * dpr;
        this.ctx.scale(dpr, dpr);
      }
      push(v){
        this.buf.push(v ?? 0); if(this.buf.length>this.capacity) this.buf.shift();
        this.draw();
      }
      draw(){
        const w = this.c.clientWidth, h=this.c.clientHeight;
        const ctx=this.ctx; ctx.clearRect(0,0,w,h);
        
        // Grid lines
        ctx.strokeStyle = 'rgba(255,255,255,0.03)';
        ctx.lineWidth = 1; ctx.beginPath();
        for(let y=h; y>=0; y-=16){ ctx.moveTo(0,y); ctx.lineTo(w,y); } 
        ctx.stroke();
        
        if(this.buf.length<2) return;
        const max = Math.max(this.yMaxHint, ...this.buf, 1);
        
        ctx.beginPath();
        ctx.strokeStyle = this.color;
        ctx.lineWidth = 3; ctx.lineJoin='round'; ctx.lineCap='round';
        
        // Draw line
        // Start from 0 to ensure fill works correctly from left
        const step = w / (this.capacity - 1);
        
        for(let i=0; i<this.buf.length; i++){
          const x = i * step;
          const val = this.buf[i];
          const y = h - (val/max)*h;
          if(i===0) ctx.moveTo(x,y);
          else ctx.lineTo(x,y);
        }
        ctx.stroke();
        
        // Fill
        ctx.lineTo(this.buf.length * step, h);
        ctx.lineTo(0, h);
        ctx.closePath();
        
        const grad = ctx.createLinearGradient(0, 0, 0, h);
        grad.addColorStop(0, hexToRgba(this.color, 0.25));
        grad.addColorStop(1, hexToRgba(this.color, 0));
        ctx.fillStyle = grad; 
        ctx.fill();
      }
    }

    function setRing(el, percent){
      if(!el) return;
      percent = clamp(percent ?? 0, 0, 100);
      el.style.setProperty('--p', percent);
      el.querySelector('span').textContent = Math.round(percent) + '%';
    }
    function setMeter(el, percent){
      if(!el) return;
      el.style.width = clamp(percent ?? 0,0,100) + '%';
    }

    function setChipText(chipEl, text){
      if(!chipEl) return;
      const value = text && text.trim().length ? text : '—';
      chipEl.classList.remove('marquee');
      chipEl.innerHTML = `<span>${value}</span>`;
      requestAnimationFrame(() => {
        const span = chipEl.querySelector('span');
        if(!span) return;
        if(span.scrollWidth > chipEl.clientWidth){
          chipEl.classList.add('marquee');
          chipEl.innerHTML = `<div class="marquee-track"><span>${value}</span><span>${value}</span></div>`;
        }
      });
    }

    function setTitleText(el, text){
      if(!el) return;
      const value = (text ?? '—').toString();
      el.classList.remove('marquee');
      el.textContent = value;
      if(value === '—'){
        el.removeAttribute('title');
      } else {
        el.title = value;
      }
    }

    const cpuSpark = new Spark($('#cpu-spark'), 120, 100, '#00f2ff');
    const gpuSpark = new Spark($('#gpu-spark'), 120, 100, '#ff8c00');
    const memSpark = new Spark($('#mem-spark'), 120, 100, '#00e676');
    const netSpark = new Spark($('#net-spark'), 120, 20, '#00f2ff');
    const diskSpark= new Spark($('#disk-spark'),120, 20, '#00f2ff');
    const cpuRingEl = document.getElementById('cpu-ring');
    const gpuRingEl = document.getElementById('gpu-ring');
    const cpuTempBar = document.getElementById('cpu-temp-bar');
    const cpuClockBar = document.getElementById('cpu-clock-bar');
    const gpuTempBar = document.getElementById('gpu-temp-bar');
    const gpuClockBar = document.getElementById('gpu-clock-bar');
    const gpuMemoryBar = document.getElementById('gpu-memory-bar');
    const memRingEl = document.getElementById('mem-ring');
    const memPressureEl = document.getElementById('mem-pressure');
    const memPressureChip = document.getElementById('mem-pressure-chip');
    // const alertsPanel = document.getElementById('alerts-panel');
    const alertListEl = document.getElementById('alert-list');
    const cpuNameChip = document.getElementById('cpu-name-chip');
    const gpuNameChip = document.getElementById('gpu-name-chip');
  const netNameChip = document.getElementById('net-name-chip');
  const netLinkChip = document.getElementById('net-link-chip');
  const netIpListEl = document.getElementById('net-ip-list');
    const gpuPrevBtn = document.getElementById('gpu-prev');
    const gpuNextBtn = document.getElementById('gpu-next');
    const netPrevBtn = document.getElementById('net-prev');
    const netNextBtn = document.getElementById('net-next');
    const tempCard = document.getElementById('temp-card');
    const tempToggleBtn = document.getElementById('temp-toggle');
    const tempListEl = document.getElementById('temp-list');
    const tempHighlightsEl = document.getElementById('temp-highlights');
  const tempMiniGridEl = document.getElementById('temp-mini-grid');
    let tempCardBaseHeight = 140;
    const updateTempCardBaseHeight = () => {
      if(tempCard.classList.contains('expanded')) return tempCardBaseHeight;
      const measured = Math.max(tempCard.offsetHeight, 140);
      tempCardBaseHeight = measured;
      tempCard.style.setProperty('--temp-card-base-height', `${Math.round(measured)}px`);
      return measured;
    };
    updateTempCardBaseHeight();
    requestAnimationFrame(updateTempCardBaseHeight);
    const fgAppNameEl = document.getElementById('fg-app-name');
    const fgProcessNameEl = document.getElementById('fg-process-name');
    const fgCpuBar = document.getElementById('fg-cpu-bar');
    const fgCpuTextEl = document.getElementById('fg-cpu');
    const fgMemBar = document.getElementById('fg-mem-bar');
    const fgMemTextEl = document.getElementById('fg-mem');
  const fgTopListEl = document.getElementById('fg-top-list');
  // Disk UI extras
  const diskActivityBar = document.getElementById('disk-activity-bar');
  const diskActivityText = document.getElementById('disk-activity-text');
  const diskTotalTextEl = document.getElementById('disk-total');
  const diskRwRatioEl = document.getElementById('disk-rw-ratio');
  const diskPeakTextEl = document.getElementById('disk-peak');

    let netList = [];
    let netIndex = 0;
    let netSummary = null;
    let gpuList = [];
    let gpuIndex = 0;
    let latestTemps = [];
    let tempHighlights = [];
    let totalMemoryGb = 0;
  // rolling history for disk total throughput (MB/s)
  const diskHistory = [];
  const diskHistoryCap = 120;

    setInterval(()=>{
      const d=new Date();
      setText('#clock', d.toLocaleTimeString());
    }, 1000);

    if(netPrevBtn){ netPrevBtn.disabled = true; }
    if(netNextBtn){ netNextBtn.disabled = true; }

    gpuPrevBtn.addEventListener('click', ()=>switchGpu(-1));
    gpuNextBtn.addEventListener('click', ()=>switchGpu(1));
    if(netPrevBtn){ netPrevBtn.addEventListener('click', ()=>switchNet(-1)); }
    if(netNextBtn){ netNextBtn.addEventListener('click', ()=>switchNet(1)); }
    tempToggleBtn.addEventListener('click', ()=>{
      const willExpand = !tempCard.classList.contains('expanded');
      if(willExpand){
        updateTempCardBaseHeight();
        tempCard.classList.add('expanded');
        tempToggleBtn.textContent = '收起';
      } else {
        tempCard.classList.remove('expanded');
        tempToggleBtn.textContent = '展开';
        setTimeout(updateTempCardBaseHeight, 320);
      }
      renderTempList();
    });

    function switchGpu(step){
      if(!gpuList.length) return;
      gpuIndex = (gpuIndex + step + gpuList.length) % gpuList.length;
      renderGpuCard(false);
    }

    function renderGpuCard(push){
      const gpu = gpuList[gpuIndex] ?? null;
      gpuPrevBtn.disabled = gpuList.length <= 1;
      gpuNextBtn.disabled = gpuList.length <= 1;

      if(gpu){
        setChipText(gpuNameChip, gpu.name || `GPU ${gpuIndex + 1}`);
        const usage = gpu.usage ?? 0;
        setText('#gpu-usage', Math.round(usage) + '%');
        setRing(gpuRingEl, usage);
        const temp = gpu.temp ?? null;
        setText('#gpu-temp', temp != null ? `${temp.toFixed(0)} ℃` : '— ℃');
        setMeter(gpuTempBar, temp != null ? clamp(temp, 0, 110) : 0);
        const clock = gpu.clock ?? null;
        setText('#gpu-clock', clock != null ? `${clock.toFixed(0)} MHz` : '— MHz');
        setMeter(gpuClockBar, clock != null ? clamp(clock / 3000 * 100, 0, 100) : 0);
        const memoryUsed = typeof gpu.memoryUsed === 'number' && !Number.isNaN(gpu.memoryUsed) ? gpu.memoryUsed : null;
        const memoryTotal = typeof gpu.memoryTotal === 'number' && !Number.isNaN(gpu.memoryTotal) ? gpu.memoryTotal : null;
  // Debug log removed; use DevTools if needed to inspect gpu object
        let memoryPct = typeof gpu.memoryUsage === 'number' && !Number.isNaN(gpu.memoryUsage) ? gpu.memoryUsage : null;
        if(memoryPct == null && memoryUsed != null && memoryTotal != null && memoryTotal > 0){
          memoryPct = memoryUsed / memoryTotal * 100;
        }
        let memoryText = '—';
        if(memoryUsed != null && memoryTotal != null && memoryTotal > 0){
          const usedText = memoryUsed >= 10 ? memoryUsed.toFixed(0) : memoryUsed.toFixed(1);
          const totalText = memoryTotal >= 10 ? memoryTotal.toFixed(0) : memoryTotal.toFixed(1);
          memoryText = `${usedText} / ${totalText} GB`;
          if(memoryPct != null){
            memoryText += ` (${Math.round(memoryPct)}%)`;
          }
        } else if(memoryPct != null){
          memoryText = `${Math.round(memoryPct)}%`;
        } else if(memoryUsed != null){
          memoryText = `${memoryUsed.toFixed(1)} GB`;
        }
        setText('#gpu-memory', memoryText);
        setMeter(gpuMemoryBar, memoryPct != null ? clamp(memoryPct, 0, 100) : 0);
        if(push) gpuSpark.push(usage);
      } else {
        setChipText(gpuNameChip, '—');
        setText('#gpu-usage', '—');
        setRing(gpuRingEl, 0);
        if(gpuRingEl){ gpuRingEl.querySelector('span').textContent = '—'; }
        setText('#gpu-temp', '— ℃');
        setMeter(gpuTempBar, 0);
        setText('#gpu-clock', '— MHz');
        setMeter(gpuClockBar, 0);
        setText('#gpu-memory', '—');
        setMeter(gpuMemoryBar, 0);
        if(push) gpuSpark.push(0);
      }
    }

    function switchNet(step){
      if(!netList.length) return;
      netIndex = (netIndex + step + netList.length) % netList.length;
      renderNetCard(false);
    }

    function renderNetCard(push){
      const adapter = netList[netIndex] ?? null;

      if(netPrevBtn){ netPrevBtn.disabled = netList.length <= 1; }
      if(netNextBtn){ netNextBtn.disabled = netList.length <= 1; }

      if(adapter){
        setChipText(netNameChip, adapter.name || `网卡 ${netIndex + 1}`);
        const up = typeof adapter.upMBps === 'number' && !Number.isNaN(adapter.upMBps) ? adapter.upMBps : 0;
        const down = typeof adapter.downMBps === 'number' && !Number.isNaN(adapter.downMBps) ? adapter.downMBps : 0;
        setText('#net-up', up.toFixed(1));
        setText('#net-down', down.toFixed(1));
        // link meta
        const linkMbps = typeof adapter.linkSpeedMbps === 'number' && isFinite(adapter.linkSpeedMbps) ? adapter.linkSpeedMbps : null;
        const typeText = adapter.connectionType === 'wireless' ? '无线' : (adapter.connectionType === 'wired' ? '有线' : null);
        let speedText = null;
        if(linkMbps != null){
          speedText = linkMbps >= 1000 ? `${(linkMbps/1000).toFixed(1)} Gbps` : `${Math.round(linkMbps)} Mbps`;
        }
        const metaText = typeText && speedText ? `${typeText} · ${speedText}` : (typeText || speedText || '—');
        if(netLinkChip){ setChipText(netLinkChip, metaText); }
        const ips = Array.isArray(adapter.ips) ? adapter.ips : (Array.isArray(adapter.ipAddresses) ? adapter.ipAddresses : []);
        renderNetIps(ips);
        if(push) netSpark.push(up + down);
        return;
      }

      if(netPrevBtn){ netPrevBtn.disabled = true; }
      if(netNextBtn){ netNextBtn.disabled = true; }
  setChipText(netNameChip, '—');
  if(netLinkChip){ setChipText(netLinkChip, '—'); }
  renderNetIps([]);

      const fallbackUp = netSummary && typeof netSummary.upMBps === 'number' && !Number.isNaN(netSummary.upMBps) ? netSummary.upMBps : 0;
      const fallbackDown = netSummary && typeof netSummary.downMBps === 'number' && !Number.isNaN(netSummary.downMBps) ? netSummary.downMBps : 0;
      setText('#net-up', fallbackUp.toFixed(1));
      setText('#net-down', fallbackDown.toFixed(1));
      if(push) netSpark.push(fallbackUp + fallbackDown);
    }

    function renderNetIps(ips){
      if(!netIpListEl) return;
      const list = Array.isArray(ips) ? ips.filter(ip => typeof ip === 'string' && ip.length) : [];
      const maxChips = 3;
      const shown = list.slice(0, maxChips);
      const extra = list.length - shown.length;
      netIpListEl.innerHTML = '&nbsp;IP:';
      const frag = document.createDocumentFragment();
      shown.forEach(ip => {
        const chip = document.createElement('div');
        chip.className = 'chip small ip-chip';
        chip.textContent = ip;
        chip.title = '点击复制';
        chip.addEventListener('click', async () => {
          try{
            await navigator.clipboard?.writeText(ip);
            const prev = chip.textContent;
            chip.textContent = '已复制';
            setTimeout(()=>{ chip.textContent = prev; }, 800);
          }catch{}
        }, { once: false });
        frag.appendChild(chip);
      });
      if(extra > 0){
        const more = document.createElement('div');
        more.className = 'chip small';
        more.textContent = `+${extra}`;
        frag.appendChild(more);
      }
      netIpListEl.appendChild(frag);
    }

function renderTempHighlights(){
  if(!tempHighlightsEl) return;

  const highlights = tempHighlights
    .filter(h => typeof h.valueC === 'number')
    .map(h => ({ label: h.label, value: h.valueC }))
    .slice(0, 3);

  if(!highlights.length){
    tempHighlightsEl.innerHTML = `
      <div class="temp-chip">
        <div class="label">无可用数据</div>
        <div class="value mono">—</div>
      </div>`;
    return;
  }

  tempHighlightsEl.innerHTML = highlights
    .map(item => `
      <div class="temp-chip">
        <div class="label">${item.label}</div>
        <div class="value mono">${item.value.toFixed(1)} ℃</div>
      </div>`)
    .join("");
}

function renderTempList(){
  if(!latestTemps.length){
    renderTempHighlights();
    renderTempMiniGrid();
    if(tempCard.classList.contains('expanded')){
      tempListEl.innerHTML = '';
    }
    return;
  }

  renderTempHighlights();
  renderTempMiniGrid();

  if(!tempCard.classList.contains('expanded')){
    return;
  }

  const orderedTemps = [...latestTemps].sort((a,b) => (b.valueC ?? -Infinity) - (a.valueC ?? -Infinity));

  tempListEl.innerHTML = orderedTemps
    .map(entry => {
      const value = entry.valueC != null ? `${entry.valueC.toFixed(1)} ℃` : '—';
      return `<li class="temp-item"><span>${entry.hardware} · ${entry.sensor}</span><span class="mono">${value}</span></li>`;
    })
    .join('');
}

function getTempSeverityClass(c){
  if(c == null || !isFinite(c)) return '';
  if(c >= 80) return 'bad';
  if(c >= 60) return 'warn';
  return 'good';
}

function renderTempMiniGrid(){
  if(!tempMiniGridEl){ return; }
  const temps = Array.isArray(latestTemps) ? latestTemps.filter(t => typeof t.valueC === 'number' && isFinite(t.valueC)) : [];
  if(!temps.length){ tempMiniGridEl.innerHTML = ''; return; }

  // Build items: use top 6 hottest unique labels
  const items = [...temps]
    .map(t => ({ label: `${t.hardware} · ${t.sensor}`, value: t.valueC }))
    .sort((a,b) => b.value - a.value);

  const seen = new Set();
  const top = [];
  for(const it of items){
    const key = it.label.toLowerCase();
    if(seen.has(key)) continue;
    seen.add(key);
    top.push(it);
    if(top.length >= 3) break;
  }

  const html = top.map(it => {
    const pct = clamp((it.value / 100) * 100, 0, 100);
    const sev = getTempSeverityClass(it.value);
    return `<div class="mini-chip ${sev}">
      <div class="label" title="${it.label}">${it.label}</div>
      <div class="value mono">${it.value.toFixed(1)} ℃</div>
      <div class="mini-bar"><i style="width:${pct}%"></i></div>
    </div>`;
  }).join('');
  tempMiniGridEl.innerHTML = html;
}

function formatDuration(totalSeconds){
  totalSeconds = Math.max(0, Math.floor(totalSeconds||0));
  const h = Math.floor(totalSeconds/3600);
  const m = Math.floor((totalSeconds%3600)/60);
  const s = totalSeconds%60;
  const pad = n => n.toString().padStart(2,'0');
  return h>0 ? `${h}:${pad(m)}:${pad(s)}` : `${m}:${pad(s)}`;
}

function renderTopForegroundApps(list){
  if(!fgTopListEl) return;
  const arr = Array.isArray(list) ? list.slice(0,3) : [];
  fgTopListEl.innerHTML = '';
  if(arr.length === 0){ return; }
  const fragment = document.createDocumentFragment();
  arr.forEach(it => {
    const name = it.displayTitle || it.name || '—';
    const dur = formatDuration(it.totalSeconds || 0);

    const chip = document.createElement('div');
    chip.className = 'chip small';

    const labelSpan = document.createElement('span');
    labelSpan.className = 'chip-label';
    labelSpan.textContent = '累计';

    const valueSpan = document.createElement('span');
    valueSpan.className = 'chip-value';
    valueSpan.textContent = dur;

    const separator = document.createElement('span');
    separator.style.opacity = '.6';
    separator.textContent = ' · ';

    const nameSpan = document.createElement('span');
    nameSpan.className = 'mono fg-chip-name';
    nameSpan.textContent = name;
    if(name && name !== '—'){
      nameSpan.title = name;
    }

    chip.append(labelSpan, valueSpan, separator, nameSpan);
    fragment.appendChild(chip);
  });
  fgTopListEl.appendChild(fragment);
}

    window.updateMetrics = function(m){
      if(m.cpu){
        const usage = m.cpu.usage ?? 0;
        setText('#cpu-usage', Math.round(usage)+'%');
        setRing(cpuRingEl, usage);
        const temp = m.cpu.temp ?? null;
        setText('#cpu-temp', temp!=null ? `${temp.toFixed(0)} ℃` : '— ℃');
        setMeter(cpuTempBar, temp!=null ? clamp(temp,0,100) : 0);
        const clock = m.cpu.clock ?? null;
        setText('#cpu-clock', clock!=null ? `${clock.toFixed(0)} MHz` : '— MHz');
        setMeter(cpuClockBar, clock!=null ? clamp(clock/6000*100,0,100) : 0);
        cpuSpark.push(usage);
        setChipText(cpuNameChip, m.cpu.name ?? '—');
      }
      if(Array.isArray(m.gpus)){
        const currentName = gpuList[gpuIndex]?.name;
        const prioritized = [...m.gpus].sort((a, b) => {
          const aName = a?.name ?? '';
          const bName = b?.name ?? '';
          const aIsNvidia = /nvidia/i.test(aName);
          const bIsNvidia = /nvidia/i.test(bName);
          if(aIsNvidia === bIsNvidia) return 0;
          return aIsNvidia ? -1 : 1;
        });
        gpuList = prioritized;
        if(!gpuList.length){
          gpuIndex = 0;
        } else if(currentName){
          const matchIndex = gpuList.findIndex(g => g.name === currentName);
          gpuIndex = matchIndex >= 0 ? matchIndex : 0;
        } else {
          gpuIndex = 0;
        }
        renderGpuCard(true);
      } else if(!gpuList.length){
        renderGpuCard(true);
      }
      if(m.mem){
        const rawUsed = typeof m.mem.usedGB === 'number' && !Number.isNaN(m.mem.usedGB) ? m.mem.usedGB : null;
        const rawTotal = typeof m.mem.totalGB === 'number' && !Number.isNaN(m.mem.totalGB) ? m.mem.totalGB : null;
        const used = rawUsed != null ? Math.max(rawUsed, 0) : null;
        const total = rawTotal != null ? Math.max(rawTotal, 0) : null;
        const pct = total && used != null && total > 0 ? clamp((used / total) * 100, 0, 100) : null;

        setText('#mem-used', used != null ? used.toFixed(1) : '--');
        setText('#mem-total', total != null ? total.toFixed(1) : '--');
        memSpark.push(pct ?? 0);
        if(total != null && total > 0){
          totalMemoryGb = total;
        }

        if(memRingEl){
          if(pct != null){
            setRing(memRingEl, pct);
          } else {
            memRingEl.style.setProperty('--p', 0);
            const span = memRingEl.querySelector('span');
            if(span) span.textContent = '--';
          }
        }

        const speed = typeof m.mem.speedMhz === 'number' && !Number.isNaN(m.mem.speedMhz) ? m.mem.speedMhz : null;
        setText('#mem-speed', speed != null ? `${Math.round(speed)} MHz` : '-- MHz');

        if(memPressureEl){
          let pressureLabel = '--';
          let pressureClass = null;
          if(pct != null){
            if(pct >= 90){
              pressureLabel = '告警';
              pressureClass = 'bad';
            } else if(pct >= 75){
              pressureLabel = '偏高';
              pressureClass = 'warn';
            } else {
              pressureLabel = '正常';
              pressureClass = 'good';
            }
          }
          memPressureEl.textContent = pressureLabel;
          if(memPressureChip){
            memPressureChip.classList.remove('good','warn','bad');
            if(pressureClass){
              memPressureChip.classList.add(pressureClass);
            }
          }
        }
      } else {
        setText('#mem-used', '--');
        setText('#mem-total', '--');
        memSpark.push(0);
        if(memRingEl){
          memRingEl.style.setProperty('--p', 0);
          const span = memRingEl.querySelector('span');
          if(span) span.textContent = '--';
        }
        setText('#mem-speed', '-- MHz');
        if(memPressureEl){
          memPressureEl.textContent = '--';
        }
        if(memPressureChip){
          memPressureChip.classList.remove('good','warn','bad');
        }
      }

      if(m.net){
        netSummary = m.net;
      }
      if(Array.isArray(m.netAdapters)){
        const currentId = netList[netIndex]?.id ?? null;
        netList = m.netAdapters;
        if(!netList.length){
          netIndex = 0;
        } else if(currentId){
          const matchIndex = netList.findIndex(n => n.id === currentId);
          netIndex = matchIndex >= 0 ? matchIndex : 0;
        } else {
          netIndex = 0;
        }
        renderNetCard(true);
      } else if(m.net){
        netList = [];
        netIndex = 0;
        renderNetCard(true);
      }
      if(m.disk){
        const r = m.disk.readMBps ?? 0;
        const w = m.disk.writeMBps ?? 0;
        setText('#disk-r', r.toFixed(1));
        setText('#disk-w', w.toFixed(1));
        const total = r + w;
        diskSpark.push(total);
        // update extras
        if(diskTotalTextEl){ diskTotalTextEl.textContent = `${total.toFixed(1)} MB/s`; }
        if(diskRwRatioEl){
          if(total > 0){
            const rp = Math.round((r/total)*100);
            const wp = 100 - rp;
            diskRwRatioEl.textContent = `${rp}% / ${wp}%`;
          } else {
            diskRwRatioEl.textContent = '—';
          }
        }
        // maintain rolling peak
        diskHistory.push(total);
        if(diskHistory.length > diskHistoryCap) diskHistory.shift();
        const peak = Math.max(0, ...diskHistory);
        if(diskPeakTextEl){ diskPeakTextEl.textContent = `${peak.toFixed(1)} MB/s`; }
        // activity percent vs rolling peak
        const activity = peak > 0 ? clamp((total/peak)*100, 0, 100) : 0;
        if(diskActivityBar){ setMeter(diskActivityBar, activity); }
        if(diskActivityText){ diskActivityText.textContent = peak > 0 ? `${Math.round(activity)} %` : '— %'; }
      }

      if(m.foregroundApp){
        const app = m.foregroundApp;
        setTitleText(fgAppNameEl, app.windowTitle || app.processName || '—');
        setChipText(fgProcessNameEl, app.processName || '—');

        const cpuUsage = app.cpuUsagePercentage ?? null;
        if(cpuUsage != null){
          fgCpuTextEl.textContent = `${cpuUsage.toFixed(1)} %`;
          setMeter(fgCpuBar, clamp(cpuUsage, 0, 100));
          // no extra chips now
        } else {
          fgCpuTextEl.textContent = '— %';
          setMeter(fgCpuBar, 0);
        }

        const memoryMb = app.memoryUsageMb ?? null;
        if(memoryMb != null){
          const display = memoryMb >= 1024 ? `${(memoryMb/1024).toFixed(1)} GB` : `${memoryMb.toFixed(0)} MB`;
          fgMemTextEl.textContent = display;
          const denominatorMb = totalMemoryGb > 0 ? totalMemoryGb * 1024 : 8192;
          const memPct = clamp((memoryMb / denominatorMb) * 100, 0, 100);
          setMeter(fgMemBar, memPct);
          // no extra chips now
        } else {
          fgMemTextEl.textContent = '— MB';
          setMeter(fgMemBar, 0);
        }
      } else {
        setTitleText(fgAppNameEl, '—');
        setChipText(fgProcessNameEl, '—');
        fgCpuTextEl.textContent = '— %';
        fgMemTextEl.textContent = '— MB';
        setMeter(fgCpuBar, 0);
        setMeter(fgMemBar, 0);
      }

      if(Array.isArray(m.topForegroundApps)){
        renderTopForegroundApps(m.topForegroundApps);
      }

      // const alerts=[];
      // if(m.cpu?.temp>85) alerts.push(`CPU 温度过高：${m.cpu.temp.toFixed(0)}℃`);
      // const activeGpu = gpuList[gpuIndex];
      // if(activeGpu?.temp>85) alerts.push(`GPU 温度过高：${activeGpu.temp.toFixed(0)}℃`);

      // if(alerts.length){
      //   alertsPanel.classList.add('has-alerts');
      //   alertListEl.innerHTML = alerts
      //     .map(a=>`<div class="alert-chip">⚠️ ${a}</div>`)
      //     .join('');
      // }else{
      //   alertsPanel.classList.remove('has-alerts');
      //   alertListEl.innerHTML = `<div class="alert-empty">当前无告警</div>`;
      // }

      tempHighlights = Array.isArray(m.temperatureHighlights) ? m.temperatureHighlights : [];
      latestTemps = Array.isArray(m.temperatures) ? m.temperatures : [];

      renderTempList();
    }

    async function fetchMetrics(){
      try{
        const res = await fetch('/api/metrics', { cache: 'no-store' });
        if(!res.ok) throw new Error(`HTTP ${res.status}`);
        const snapshot = await res.json();

        if(snapshot.machineName){
          const hostDetail = [snapshot.machineName, snapshot.osVersion, snapshot.motherboard].filter(Boolean).join(' · ');
          setText('#host', hostDetail);
        }

        if(snapshot.timestamp){
          const time = new Date(snapshot.timestamp);
          setText('#ver', `采集 ${time.toLocaleTimeString()}`);
        }

        const cpu = snapshot.cpu ?? {};
        const gpus = Array.isArray(snapshot.gpus) ? snapshot.gpus : [];
        const mem = snapshot.memory ?? {};
        const net = snapshot.network ?? {};
        const netAdapters = Array.isArray(snapshot.networkAdapters) ? snapshot.networkAdapters : [];
        const disk = snapshot.disk ?? {};
        const temps = Array.isArray(snapshot.temperatures) ? snapshot.temperatures : [];
        const tempHighlightsData = Array.isArray(snapshot.temperatureHighlights) ? snapshot.temperatureHighlights : [];

        window.updateMetrics({
          cpu: {
            name: snapshot.cpu?.name ?? null,
            usage: cpu.totalLoadPercentage ?? 0,
            temp: cpu.packageTemperatureC ?? null,
            clock: cpu.clockMhz ?? null
          },
          gpus: gpus.map(gpu => ({
            name: gpu.name ?? '',
            usage: gpu.loadPercentage ?? 0,
            temp: gpu.temperatureC ?? null,
            clock: gpu.coreClockMhz ?? null,
            memoryUsed: gpu.memoryUsedGb ?? null,
            memoryTotal: gpu.memoryTotalGb ?? null,
            memoryUsage: gpu.memoryUsagePercentage ?? null
          })),
          mem: {
            usedGB: mem.usedGb ?? null,
            totalGB: mem.totalGb ?? null,
            speedMhz: mem.speedMhz ?? null
          },
          net: {
            upMBps: net.uploadMBps ?? 0,
            downMBps: net.downloadMBps ?? 0
          },
          netAdapters: netAdapters.map(adapter => ({
            id: adapter.identifier ?? '',
            name: adapter.name ?? '',
            upMBps: adapter.uploadMBps ?? null,
            downMBps: adapter.downloadMBps ?? null,
            linkSpeedMbps: adapter.linkSpeedMbps ?? null,
            connectionType: adapter.connectionType ?? null,
            ips: Array.isArray(adapter.ipAddresses) ? adapter.ipAddresses : []
          })),
          disk: {
            readMBps: disk.readMbps ?? 0,
            writeMBps: disk.writeMbps ?? 0
          },
          temperatures: temps,
          temperatureHighlights: tempHighlightsData,
          foregroundApp: snapshot.foregroundApp ?? null,
          topForegroundApps: Array.isArray(snapshot.topForegroundApps) ? snapshot.topForegroundApps : []
        });
      }catch(err){
        console.error('获取监控数据失败', err);
      }
    }

    setChipText(cpuNameChip, '—');
    setChipText(gpuNameChip, '—');
    setChipText(netNameChip, '—');
    renderTempHighlights();

    fetchMetrics();
    setInterval(fetchMetrics, 2000);

    // Light Effect Logic
    const cards = document.querySelectorAll('.card');
    let time = 0;
    
    // State
    let isAutoColor = true;
    let manualColorHex = '#00f2ff';
    let manualColorRgb = '0, 242, 255';
    let mouseX = 0, mouseY = 0;
    let isMouseInWindow = false;

    // UI Elements
    const clockBtn = document.getElementById('clock');
    const modalOverlay = document.getElementById('settings-modal');
    const modalCloseBtn = document.getElementById('modal-close');
    const autoColorToggle = document.getElementById('auto-color-toggle');
    const manualColorPicker = document.getElementById('manual-color-picker');
    const intensitySlider = document.getElementById('intensity-slider');

    // Event Listeners
    window.addEventListener('mousemove', (e) => {
      mouseX = e.clientX;
      mouseY = e.clientY;
      isMouseInWindow = true;
    });
    document.addEventListener('mouseleave', () => {
      isMouseInWindow = false;
    });

    clockBtn.addEventListener('click', () => {
      modalOverlay.classList.add('open');
    });
    modalCloseBtn.addEventListener('click', () => {
      modalOverlay.classList.remove('open');
    });
    modalOverlay.addEventListener('click', (e) => {
      if(e.target === modalOverlay) modalOverlay.classList.remove('open');
    });

    autoColorToggle.addEventListener('change', (e) => {
      isAutoColor = e.target.checked;
      manualColorPicker.disabled = isAutoColor;
    });

    manualColorPicker.addEventListener('input', (e) => {
      manualColorHex = e.target.value;
      const r = parseInt(manualColorHex.slice(1, 3), 16);
      const g = parseInt(manualColorHex.slice(3, 5), 16);
      const b = parseInt(manualColorHex.slice(5, 7), 16);
      manualColorRgb = `${r}, ${g}, ${b}`;
    });

    intensitySlider.addEventListener('input', (e) => {
      document.documentElement.style.setProperty('--light-intensity', e.target.value);
    });

    function getSunlightColor() {
      const now = new Date();
      const hour = now.getHours() + now.getMinutes() / 60 + now.getSeconds() / 3600;
      
      // [Hour, R, G, B] - Simulating Day/Night Cycle
      const points = [
        [0, 60, 80, 140],    // Midnight: Cool Moonlight
        [5, 70, 90, 150],    // Pre-dawn
        [6, 255, 100, 60],   // Sunrise: Orange/Red
        [8, 255, 220, 180],  // Morning: Warm
        [12, 255, 255, 255], // Noon: Bright White
        [16, 255, 230, 190], // Afternoon: Golden
        [18, 255, 130, 70],  // Sunset: Deep Orange
        [19.5, 100, 90, 160],// Twilight: Purple
        [21, 60, 80, 140],   // Night: Blue Moonlight
        [24, 60, 80, 140]    // Wrap
      ];

      let p1 = points[0];
      let p2 = points[points.length - 1];
      
      for (let i = 0; i < points.length - 1; i++) {
        if (hour >= points[i][0] && hour < points[i+1][0]) {
          p1 = points[i];
          p2 = points[i+1];
          break;
        }
      }

      const t = (hour - p1[0]) / (p2[0] - p1[0]);
      const r = Math.round(p1[1] + (p2[1] - p1[1]) * t);
      const g = Math.round(p1[2] + (p2[2] - p1[2]) * t);
      const b = Math.round(p1[3] + (p2[3] - p1[3]) * t);
      
      return `${r}, ${g}, ${b}`;
    }

    let currentX = window.innerWidth / 2;
    let currentY = -100;
    let currentSize = 1000;

    function updateLight() {
      time += 0.005;
      const w = window.innerWidth;
      const h = window.innerHeight;
      
      // Position Logic
      let targetX, targetY, targetSize;
      if (isMouseInWindow) {
        // God Rays / Focus Mode
        targetX = mouseX;
        targetY = mouseY;
        targetSize = 600;
      } else {
        // Sky Light / Diffuse Mode
        // Simulate Sun/Moon path: East (Left) -> West (Right)
        const now = new Date();
        const hour = now.getHours() + now.getMinutes() / 60 + now.getSeconds() / 3600;
        
        // Cycle: 6am -> 0.0, 12pm -> 0.5, 18pm -> 1.0 (Day)
        //        18pm -> 0.0, 24am -> 0.5, 6am -> 1.0 (Night)
        // We use a 12-hour cycle offset by 6 hours
        const cycleProgress = ((hour - 6 + 24) % 24) / 12; // 0..2 range
        const normalizedProgress = cycleProgress % 1; // 0..1 range for current pass
        
        targetX = normalizedProgress * w;
        
        // Arc path: High at noon/midnight (0.5), Low at horizon (0.0/1.0)
        // Using sin(PI * p) -> 0 at ends, 1 at center
        const arcHeight = 200;
        const baseY = -50;
        targetY = baseY - (Math.sin(normalizedProgress * Math.PI) * arcHeight);
        
        // Add slight wobble for atmosphere
        targetX += Math.sin(time * 0.5) * 20;
        
        targetSize = Math.max(w, h) * 1.2; 
      }

      // Smooth transition (Lerp)
      currentX += (targetX - currentX) * 0.1;
      currentY += (targetY - currentY) * 0.1;
      currentSize += (targetSize - currentSize) * 0.1;

      // Color Logic
      let currentRgb;
      if (isAutoColor) {
        currentRgb = getSunlightColor();
      } else {
        currentRgb = manualColorRgb;
      }

      cards.forEach(card => {
        const rect = card.getBoundingClientRect();
        const x = currentX - rect.left;
        const y = currentY - rect.top;
        card.style.setProperty('--rx', `${x}px`);
        card.style.setProperty('--ry', `${y}px`);
        card.style.setProperty('--light-size', `${currentSize}px`);
        card.style.setProperty('--light-rgb', currentRgb);
      });
      requestAnimationFrame(updateLight);
    }
    requestAnimationFrame(updateLight);
  </script>
</body>
</html>


