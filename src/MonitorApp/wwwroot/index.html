<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <meta name="theme-color" content="#050505" />
  <link rel="icon" type="image/png" sizes="64x64" href="/favicon.png">
  <title>系统监控</title>
  <link rel="manifest" href="manifest.json" />
  <link href="css/inter.css" rel="stylesheet">
  <link href="css/remixicon.css" rel="stylesheet">
  <style>
    :root {
      /* Default Theme (Midnight) */
      --bg: #050505;
      --bg-gradient-start: #1a2c4e;
      --bg-gradient-end: #050505;
      --cloud-1: rgba(0, 242, 255, 0.15);
      --cloud-2: rgba(25, 118, 210, 0.15);
      --cloud-3: rgba(123, 31, 162, 0.15);
      
      --card-bg: rgba(20, 30, 45, 0.6);
      --card-border: rgba(255, 255, 255, 0.08);
      --text-main: #ffffff;
      --text-muted: #94a3b8;
      --accent-primary: #00f2ff;
      --accent-secondary: #ff8c00;
      --accent-tertiary: #00e676;
      --glass-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.36);
      --grid-line: rgba(255, 255, 255, 0.06);
      --chip-bg: rgba(255, 255, 255, 0.05);
      --good: #00e676;
      --warn: #ffea00;
      --bad: #ff1744;
    }

    /* Theme: Cyberpunk */
    [data-theme="cyberpunk"] {
      --bg: #0a0014;
      --bg-gradient-start: #2d004d;
      --bg-gradient-end: #0a0014;
      --cloud-1: rgba(255, 0, 212, 0.15);
      --cloud-2: rgba(0, 255, 242, 0.15);
      --cloud-3: rgba(111, 0, 255, 0.15);
      --accent-primary: #ff00d4;
      --accent-secondary: #00fff2;
      --accent-tertiary: #ffe600;
      --card-bg: rgba(45, 0, 45, 0.4);
    }

    /* Theme: Forest */
    [data-theme="forest"] {
      --bg: #051405;
      --bg-gradient-start: #0f3d0f;
      --bg-gradient-end: #051405;
      --cloud-1: rgba(0, 255, 128, 0.15);
      --cloud-2: rgba(139, 195, 74, 0.15);
      --cloud-3: rgba(0, 150, 136, 0.15);
      --accent-primary: #00e676;
      --accent-secondary: #cddc39;
      --accent-tertiary: #4caf50;
      --card-bg: rgba(10, 30, 15, 0.6);
    }

    /* Theme: Sunset */
    [data-theme="sunset"] {
      --bg: #1a0505;
      --bg-gradient-start: #4d1a1a;
      --bg-gradient-end: #1a0505;
      --cloud-1: rgba(255, 87, 34, 0.15);
      --cloud-2: rgba(255, 193, 7, 0.15);
      --cloud-3: rgba(156, 39, 176, 0.15);
      --accent-primary: #ff5722;
      --accent-secondary: #ffc107;
      --accent-tertiary: #e91e63;
      --card-bg: rgba(40, 15, 15, 0.6);
    }

    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0;
      font-family: 'Inter', system-ui, -apple-system, sans-serif;
      background: var(--bg);
      color: var(--text-main);
      overflow: hidden;
      position: relative;
    }

    /* Volumetric Clouds Background */
    .bg-fx {
      position: fixed; inset: 0; z-index: -2;
      overflow: hidden; pointer-events: none;
      background: radial-gradient(circle at 50% 0%, var(--bg-gradient-start), var(--bg-gradient-end) 80%);
    }
    #webgl-canvas {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      z-index: -1;
      opacity: 1.0;
      mix-blend-mode: overlay;
    }
    /* Legacy CSS Blobs (Fallback) */
    /* body.use-webgl .blob { display: none !important; } */
    body.use-webgl #global-light { display: none !important; }

    .blob {
      position: absolute;
      border-radius: 50%;
      filter: blur(80px);
      opacity: 0.6;
      animation: float 20s infinite ease-in-out;
      mix-blend-mode: screen;
      will-change: transform;
    }
    .blob-1 { top: -10%; left: -10%; width: 50vw; height: 50vw; background: var(--cloud-1); animation-delay: 0s; }
    .blob-2 { top: 20%; right: -20%; width: 60vw; height: 60vw; background: var(--cloud-2); animation-delay: -5s; }
    .blob-3 { bottom: -20%; left: 20%; width: 70vw; height: 60vw; background: var(--cloud-3); animation-delay: -10s; }

    /* Performance Optimization: Pause animations when idle */
    body.paused .blob {
      animation-play-state: paused;
    }
    body.static-clouds .blob {
      animation: none !important;
      display: block; /* Ensure they are visible but static */
    }
    body.paused .card, body.paused header {
      backdrop-filter: none;
      -webkit-backdrop-filter: none;
      transition: background 0.3s, backdrop-filter 0.3s; 
    }

    @keyframes float {
      0%, 100% { transform: translate(0, 0) scale(1); }
      33% { transform: translate(30px, -50px) scale(1.1); }
      66% { transform: translate(-20px, 20px) scale(0.9); }
    }

    .app {
      height: 100vh;
      overflow-y: auto;
      padding: 24px;
      display: flex;
      flex-direction: column;
      gap: 24px;
      scrollbar-width: thin;
      scrollbar-color: var(--accent-primary) transparent;
      max-width: 1600px;
      margin: 0 auto;
    }
    .app::-webkit-scrollbar { width: 8px; }
    .app::-webkit-scrollbar-track { background: transparent; }
    .app::-webkit-scrollbar-thumb {
      background: var(--accent-primary);
      border-radius: 99px;
    }
    
    /* Global Light Overlay (for Cloud Interaction) */
    #global-light {
      position: fixed;
      inset: 0;
      pointer-events: none;
      z-index: -1; /* Behind content, above body background */
      opacity: 0;
      transition: opacity 0.5s;
      mix-blend-mode: overlay;
      background-image: 
        /* Mouse Spot (Interactive) */
        radial-gradient(
          600px circle at var(--mouse-x, -1000px) var(--mouse-y, -1000px), 
          rgba(var(--light-rgb), var(--spot-opacity, 0)) 0%, 
          transparent 60%
        ),
        /* Sun Beam (Interactive) */
        conic-gradient(
          from var(--beam-start, 0deg) at var(--sun-x, 50vw) var(--sun-y, -100px), 
          transparent 0deg, 
          rgba(var(--light-rgb), var(--beam-opacity, 0)) 15deg, 
          transparent 30deg
        );
    }
    body.cloud-interaction #global-light {
      opacity: var(--light-intensity, 1);
    }
    
    /* Header */
    header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 16px 24px;
      background: rgba(255, 255, 255, 0.03);
      border: 1px solid var(--card-border);
      border-radius: 24px;
      backdrop-filter: blur(16px);
      position: sticky;
      top: 0;
      z-index: 10;
      box-shadow: var(--glass-shadow);
    }
    .title { font-weight: 700; font-size: 18px; letter-spacing: -0.5px; }
    .subtitle { color: var(--text-muted); font-size: 13px; font-weight: 500; }

    /* Grid */
    .content { flex: 1 0 auto; display: flex; gap: 24px; }
    .grid {
      flex: 1;
      display: grid;
      gap: 24px;
      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
      align-content: start;
      grid-auto-flow: dense;
    }
    
    /* Cards */
    .card {
      background: linear-gradient(135deg, rgba(255,255,255,0.05), rgba(255,255,255,0.01));
      border: 1px solid var(--card-border);
      border-radius: 24px;
      padding: 24px;
      display: flex;
      flex-direction: column;
      gap: 16px;
      box-shadow: var(--glass-shadow);
      backdrop-filter: blur(12px);
      transition: border-color 0.3s ease;
      position: relative;
      overflow: hidden;
      --light-rgb: 255, 255, 255;
    }
    .card::before {
      content: "";
      position: absolute;
      inset: 0;
      border-radius: 24px;
      padding: 1.5px;
      background-image: 
        /* Mouse Spot (Interactive) */
        radial-gradient(
          600px circle at var(--mouse-x, -1000px) var(--mouse-y, -1000px), 
          rgba(var(--light-rgb), var(--spot-opacity, 0)) 0%, 
          transparent 60%
        ),
        /* Sun Beam (Interactive) */
        conic-gradient(
          from var(--beam-start, 0deg) at var(--sun-x, 50vw) var(--sun-y, -100px), 
          transparent 0deg, 
          rgba(var(--light-rgb), var(--beam-opacity, 0)) 15deg, 
          transparent 30deg
        ),
        /* Sun Ambient (Always) */
        radial-gradient(
          var(--light-size) circle at var(--sun-x, 50vw) var(--sun-y, -100px), 
          rgba(var(--light-rgb), 0.6) 0%, 
          rgba(var(--light-rgb), 0.1) 40%,
          transparent 80%
        );
      background-attachment: fixed;
      -webkit-mask: 
        linear-gradient(#fff 0 0) content-box, 
        linear-gradient(#fff 0 0);
      -webkit-mask-composite: xor;
      mask-composite: exclude;
      pointer-events: none;
      opacity: var(--light-intensity, 1);
      transition: opacity 0.5s;
    }
    .card::after {
      content: "";
      position: absolute;
      inset: 0;
      border-radius: 24px;
      background-image: 
        /* Mouse Spot Glow */
        radial-gradient(
          900px circle at var(--mouse-x, -1000px) var(--mouse-y, -1000px), 
          rgba(var(--light-rgb), calc(var(--spot-opacity, 0) * 0.15)),
          transparent 60%
        ),
        /* Sun Ambient Glow */
        radial-gradient(
          calc(var(--light-size) * 1.5) circle at var(--sun-x, 50vw) var(--sun-y, -100px), 
          rgba(var(--light-rgb), 0.08),
          transparent 60%
        );
      background-attachment: fixed;
      pointer-events: none;
      opacity: var(--light-intensity, 1);
    }
    .card:hover {
      border-color: rgba(255, 255, 255, 0.3);
    }
    .card.span-2 { grid-column: span 2; }

    /* Typography & Components */
    .row { display: flex; align-items: flex-start; gap: 16px; }
    .grow { flex: 1; min-width: 0; }
    .label { color: var(--text-muted); font-size: 12px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; line-height: 1.5; }
    .value { font-weight: 700; font-size: 28px; letter-spacing: -1px; line-height: 1.2; }
    .unit { font-size: 14px; opacity: 0.7; font-weight: 500; }
    .mono { font-family: 'Inter', monospace; font-variant-numeric: tabular-nums; }
    
    /* Icons */
    .icon {
      width: 48px; height: 48px;
      background: rgba(255,255,255,0.03);
      border: 1px solid var(--card-border);
      border-radius: 12px;
      display: grid; place-items: center;
      flex-shrink: 0;
      font-size: 24px;
      color: var(--accent-primary);
      opacity: 0.9;
    }
    
    /* Chips */
    .chip {
      display: inline-flex; align-items: center; gap: 8px;
      padding: 6px 12px;
      border-radius: 99px;
      background: var(--chip-bg);
      border: 1px solid var(--card-border);
      font-size: 13px;
      color: var(--text-main);
    }
    .chip.small { font-size: 12px; padding: 4px 10px; }
    .chip-row { display: flex; flex-wrap: wrap; gap: 8px; margin-top: 4px; }
    .chip-label { color: var(--text-muted); margin-right: 4px; }
    .chip-value { font-weight: 600; }
    .chip.good { background: rgba(0, 230, 118, 0.1); border-color: rgba(0, 230, 118, 0.3); color: var(--good); }
    .chip.warn { background: rgba(255, 234, 0, 0.1); border-color: rgba(255, 234, 0, 0.3); color: var(--warn); }
    .chip.bad { background: rgba(255, 23, 68, 0.1); border-color: rgba(255, 23, 68, 0.3); color: var(--bad); }

    /* Rings & Meters */
    .ring {
      --p: 0; --col: var(--accent-primary);
      width: 80px; height: 80px;
      border-radius: 50%;
      position: relative;
      background: conic-gradient(var(--col) calc(var(--p)*1%), rgba(255,255,255,0.05) 0);
      display: grid; place-items: center;
      flex-shrink: 0;
      box-shadow: 0 0 20px rgba(0,0,0,0.2);
      align-self: center;
    }
    .ring::before {
      content: ""; position: absolute; inset: 8px;
      background: #131b29; /* Darker inner circle to simulate hole */
      border-radius: 50%;
    }
    .ring span { position: relative; font-weight: 700; font-size: 18px; }

    .meter {
      height: 8px;
      background: rgba(255,255,255,0.05);
      border-radius: 99px;
      overflow: hidden;
    }
    .meter > i {
      display: block; height: 100%; width: 0;
      background: var(--accent-primary);
      transition: width 0.5s cubic-bezier(0.4, 0, 0.2, 1);
      box-shadow: 0 0 10px var(--accent-primary);
    }

    .kv { display: grid; grid-template-columns: auto 1fr auto; gap: 8px 16px; align-items: center; font-size: 13px; }
    
    /* Canvas */
    canvas.spark {
      width: 100%; height: 64px;
      background: rgba(0,0,0,0.2);
      border-radius: 16px;
      border: 1px solid var(--card-border);
      margin-top: auto;
      display: block;
    }

    /* Footer */
    footer {
      display: flex; justify-content: space-between; align-items: center;
      color: var(--text-muted); font-size: 12px;
      padding: 0 12px;
    }

    /* Specific Components */
    .gpu-button {
      width: 28px; height: 28px;
      border-radius: 8px;
      border: 1px solid var(--card-border);
      background: rgba(255,255,255,0.05);
      color: var(--text-main);
      display: grid; place-items: center;
      cursor: pointer;
      transition: all 0.2s;
    }
    .gpu-button:hover:not(:disabled) {
      background: var(--accent-primary);
      color: #000;
      box-shadow: 0 0 12px var(--accent-primary);
    }
    .gpu-button:disabled { opacity: 0.3; cursor: not-allowed; }
    
    .gpu-name-switch { display: flex; align-items: center; gap: 8px; margin-top: 4px; }
    .gpu-ring-wrap { width: 80px; height: 80px; display: flex; align-items: center; justify-content: center; flex-shrink: 0; }
    .gpu-ring-wrap .ring { width: 80px; height: 80px; }
    
    /* Marquee */
    .name-chip { max-width: 180px; overflow: hidden; white-space: nowrap; min-width: 0; }
    .name-chip.marquee { position: relative; }
    .name-chip.marquee .marquee-track { display: inline-flex; animation: marquee 10s linear infinite; }
    .name-chip.marquee .marquee-track span { padding-right: 24px; }
    @keyframes marquee { 0% { transform: translateX(0); } 100% { transform: translateX(-50%); } }
    
    /* Foreground app title marquee */
    .title-text {
      font-size: 18px;
      font-weight: 700;
      overflow: hidden;
      text-overflow: ellipsis;
      display: -webkit-box;
      -webkit-box-orient: vertical;
      -webkit-line-clamp: 2;
      line-clamp: 2;
      white-space: normal;
      word-break: break-word;
    }
    .title-text.marquee { position: relative; }
    .title-text.marquee .marquee-track { display: inline-flex; white-space: nowrap; animation: marquee 10s linear infinite; }
    .title-text.marquee .marquee-track span { padding-right: 32px; }
    #fg-top-list { min-width: 0; }
    #fg-top-list .chip { max-width: 100%; min-width: 0; }
    #fg-top-list .fg-chip-name { flex: 1; min-width: 0; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }

    /* Temp Card */
    .temp-card {
      --temp-card-base-height: 140px;
      min-height: var(--temp-card-base-height);
      transition: min-height 0.4s cubic-bezier(0.4, 0, 0.2, 1);
    }
    .temp-card.expanded { min-height: calc(var(--temp-card-base-height) * 2); }
    .temp-card .temp-header { display: flex; justify-content: space-between; align-items: flex-start; gap: 12px; }
    .temp-highlights { display: flex; gap: 8px; flex-wrap: wrap; margin-top: 6px; }
    
    .temp-toggle {
      background: rgba(255,255,255,0.05);
      border: 1px solid var(--card-border);
      color: var(--text-main);
      padding: 6px 12px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 12px;
      transition: all 0.2s;
    }
    .temp-toggle:hover { background: rgba(255,255,255,0.1); }
    
    .temp-chip {
      background: linear-gradient(135deg, rgba(0, 242, 255, 0.1), rgba(0,0,0,0));
      border: 1px solid rgba(0, 242, 255, 0.2);
      border-radius: 16px;
      padding: 12px;
      min-width: 100px;
      display: flex; flex-direction: column; gap: 4px;
    }
    .temp-chip .label { font-size: 11px; color: var(--text-muted); }
    .temp-chip .value { font-size: 18px; font-weight: 600; }
    
    .temp-list-wrapper {
      margin-top: 16px;
      background: rgba(0,0,0,0.2);
      border-radius: 16px;
      overflow: hidden;
      max-height: 0;
      transition: max-height 0.4s ease;
    }
    .temp-card.expanded .temp-list-wrapper { max-height: 400px; }
    .temp-list { padding: 12px; margin: 0; list-style: none; display: flex; flex-direction: column; gap: 8px; overflow-y: auto; max-height: 380px; }
    .temp-item {
      display: flex; justify-content: space-between;
      padding: 8px 12px;
      background: rgba(255,255,255,0.03);
      border-radius: 8px;
      font-size: 13px;
      border: 1px solid var(--card-border);
    }
    
    /* Mini Temp Grid */
    .temp-mini-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); gap: 8px; margin-top: 10px; }
    .temp-card.expanded .temp-mini-grid { display: none; }
    .mini-chip {
      display: flex; flex-direction: column; gap: 6px;
      padding: 8px 10px; border-radius: 10px;
      background: rgba(255,255,255,0.04);
      border: 1px solid var(--card-border);
      min-width: 0;
    }
    .mini-chip .label { font-size: 11px; color: var(--text-muted); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .mini-chip .value { font-size: 16px; font-weight: 700; }
    .mini-chip.good { background: rgba(0, 230, 118, 0.1); border-color: rgba(0, 230, 118, 0.3); }
    .mini-chip.warn { background: rgba(255, 234, 0, 0.1); border-color: rgba(255, 234, 0, 0.3); }
    .mini-chip.bad { background: rgba(255, 23, 68, 0.1); border-color: rgba(255, 23, 68, 0.3); }
    .mini-bar { height: 6px; border-radius: 999px; background: rgba(255,255,255,0.1); overflow: hidden; }
    .mini-bar > i { display: block; height: 100%; width: 40%; background: linear-gradient(90deg, #58a6ff, #ff8a65); }

    /* Responsive */
    @media (max-width: 1100px) {
      .grid { grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); }
      .content { flex-direction: column; }
      .panel-card { flex: 1; min-height: auto; }
    }
    @media (max-width: 768px) {
      .app { padding: 16px; gap: 16px; }
      .grid { grid-template-columns: 1fr; }
      .card.span-2 { grid-column: span 1; }
      .row { flex-wrap: wrap; }
    }

    /* Modal */
    .modal-overlay {
      position: fixed; inset: 0;
      background: rgba(0,0,0,0.6);
      backdrop-filter: blur(4px);
      z-index: 100;
      display: none;
      place-items: center;
      opacity: 0;
      transition: opacity 0.3s;
    }
    .modal-overlay.open { display: grid; opacity: 1; }
    .modal {
      background: #131b29;
      border: 1px solid var(--card-border);
      border-radius: 24px;
      padding: 24px;
      width: 90%; max-width: 400px;
      box-shadow: var(--glass-shadow);
      transform: scale(0.9);
      transition: transform 0.3s;
    }
    .modal-overlay.open .modal { transform: scale(1); }
    .modal-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px; }
    .modal-title { font-size: 18px; font-weight: 700; }
    .modal-close { background: none; border: none; color: var(--text-muted); cursor: pointer; font-size: 24px; }
    .modal-body { display: flex; flex-direction: column; gap: 16px; }
    .control-row { display: flex; justify-content: space-between; align-items: center; }
    
    /* Select Styling */
    #theme-select {
      background: rgba(255,255,255,0.1);
      border: 1px solid var(--card-border);
      color: white;
      padding: 4px 8px;
      border-radius: 4px;
      outline: none;
    }
    #theme-select option {
      background-color: #131b29;
      color: white;
    }

    .switch {
      position: relative; display: inline-block; width: 48px; height: 24px;
    }
    .switch input { opacity: 0; width: 0; height: 0; }
    .slider {
      position: absolute; cursor: pointer; inset: 0;
      background-color: rgba(255,255,255,0.1);
      border-radius: 24px; transition: .4s;
    }
    .slider:before {
      position: absolute; content: "";
      height: 18px; width: 18px; left: 3px; bottom: 3px;
      background-color: white; border-radius: 50%; transition: .4s;
    }
    input:checked + .slider { background-color: var(--accent-primary); }
    input:checked + .slider:before { transform: translateX(24px); }
    input:disabled + .slider { opacity: 0.5; cursor: not-allowed; }
  </style>
</head>
<body>
  <div class="bg-fx">
    <canvas id="webgl-canvas"></canvas>
    <div class="blob blob-1"></div>
    <div class="blob blob-2"></div>
    <div class="blob blob-3"></div>
  </div>
  <div class="app">
    <header>
      <div>
        <div class="title">系统监控</div>
        <div class="subtitle" id="host">—</div>
      </div>
      <button class="chip" id="clock" style="cursor:pointer; border:none; font-family:inherit; font-size:inherit; outline:none;">00:00:00</button>
    </header>

    <div class="content">
      <main class="grid">
        <section class="card span-2">
          <div class="card-content">
            <div class="row">
               <i class="ri-cpu-line icon"></i>
              <div class="grow">
                <div class="label">CPU</div>
                <div class="value mono" id="cpu-usage">0%</div>
                <div class="chip small name-chip cpu-name" id="cpu-name-chip"><span>—</span></div>
              </div>
              <div class="ring" id="cpu-ring"><span class="mono" id="cpu-ring-val">0%</span></div>
            </div>
            <div class="kv">
              <div class="label">温度</div><div class="meter"><i id="cpu-temp-bar"></i></div><div class="mono" id="cpu-temp">— ℃</div>
              <div class="label">频率</div><div class="meter"><i id="cpu-clock-bar"></i></div><div class="mono" id="cpu-clock">— MHz</div>
            </div>
          </div>
          <canvas class="spark" id="cpu-spark"></canvas>
        </section>

        <section class="card span-2" id="gpu-card">
          <div class="card-content">
            <div class="row">
              <i class="ri-dashboard-3-line icon"></i>
              <div class="grow">
                <div class="label">GPU</div>
                <div class="value mono" id="gpu-usage">0%</div>
                <div class="gpu-name-switch">
                  <button type="button" class="gpu-button prev" id="gpu-prev" aria-label="上一块 GPU">&#60;</button>
                  <div class="chip small name-chip gpu-name" id="gpu-name-chip"><span>—</span></div>
                  <button type="button" class="gpu-button next" id="gpu-next" aria-label="下一块 GPU">&#62;</button>
                </div>
              </div>
              <div class="gpu-ring-wrap">
                <div class="ring" id="gpu-ring" style="--col:var(--accent-secondary)"><span class="mono" id="gpu-ring-val">0%</span></div>
              </div>
            </div>
            <div class="kv">
              <div class="label">温度</div><div class="meter"><i id="gpu-temp-bar" style="background:linear-gradient(90deg,var(--accent-secondary),#ff8a65)"></i></div><div class="mono" id="gpu-temp">— ℃</div>
              <div class="label">频率</div><div class="meter"><i id="gpu-clock-bar" style="background:linear-gradient(90deg,var(--accent-secondary),#ff8a65)"></i></div><div class="mono" id="gpu-clock">— MHz</div>
              <div class="label">显存</div><div class="meter"><i id="gpu-memory-bar" style="background:linear-gradient(90deg,var(--accent-secondary),#ff8a65)"></i></div><div class="mono" id="gpu-memory">—</div>
            </div>
          </div>
          <canvas class="spark" id="gpu-spark"></canvas>
        </section>

        <section class="card">
          <div class="card-content">
            <div class="row">
              <div class="grow">
                <div class="label">内存概览</div>
                <div class="value mono"><span id="mem-used">--</span> / <span id="mem-total">--</span> <span class="unit">GB</span></div>
              </div>
              <div class="ring" id="mem-ring" style="--col:var(--accent-tertiary)"><span class="mono">0%</span></div>
            </div>
            <div class="chip-row">
              <div class="chip small" id="mem-speed-chip">
                <span class="chip-label">内存速度</span>
                <span class="chip-value mono" id="mem-speed">-- MHz</span>
              </div>
              <div class="chip small" id="mem-pressure-chip">
                <span class="chip-label">压力状态</span>
                <span class="chip-value mono" id="mem-pressure">--</span>
              </div>
            </div>
          </div>
          <canvas class="spark" id="mem-spark"></canvas>
        </section>

        <section class="card" id="fg-card">
          <div class="card-content">
            <div class="row">
              <div class="grow">
                <div class="label">前台应用</div>
                <div class="value title-text" id="fg-app-name">—</div>
                <div class="chip small" id="fg-process-name">—</div>
              </div>
            </div>
            <div class="kv">
              <div class="label">CPU</div><div class="meter"><i id="fg-cpu-bar"></i></div><div class="mono" id="fg-cpu">— %</div>
              <div class="label">内存</div><div class="meter"><i id="fg-mem-bar" style="background:linear-gradient(90deg,var(--accent-tertiary),#a5d66a)"></i></div><div class="mono" id="fg-mem">— MB</div>
            </div>
            <div class="chip-row" id="fg-top-list" style="margin-top:6px"></div>
          </div>
        </section>



        <section class="card">
          <div class="card-content">
            <div class="row">
              <div class="grow">
                <div class="label">网络</div>
                <div class="gpu-name-switch net-name-switch">
                  <button type="button" class="gpu-button prev" id="net-prev" aria-label="上一块网卡">&#60;</button>
                  <div class="chip small name-chip net-name" id="net-name-chip"><span>—</span></div>
                  <button type="button" class="gpu-button next" id="net-next" aria-label="下一块网卡">&#62;</button>
                </div>
                <div class="mono"  style="padding-top: 5px; padding-left: 10px;">↑ <span id="net-up">0.0</span> MB/s &nbsp; ↓ <span id="net-down">0.0</span> MB/s</div>
                <div class="chip-row" style="padding-top: 5px; padding-left: 6px; gap:6px">
                  <div class="chip small" id="net-link-chip"></div>
                </div>
                <div class="chip-row" style="padding-top: 5px; padding-left: 6px; gap:6px" id="net-ip-list"></div>
              </div>
            </div>
          </div>
          <canvas class="spark" id="net-spark"></canvas>
        </section>

        <section class="card">
          <div class="card-content">
            <div class="row">
              <div class="grow">
                <div class="label">磁盘 I/O</div>
                <div class="mono">R <span id="disk-r">0.0</span> MB/s &nbsp; W <span id="disk-w">0.0</span> MB/s</div>
                <div class="chip-row" style="margin-top:6px">
                  <div class="chip small" id="disk-total-chip">
                    <span class="chip-label">总吞吐</span>
                    <span class="chip-value mono" id="disk-total">0.0 MB/s</span>
                  </div>
                  <div class="chip small" id="disk-rw-chip">
                    <span class="chip-label">读/写占比</span>
                    <span class="chip-value mono" id="disk-rw-ratio">—</span>
                  </div>
                  <div class="chip small" id="disk-peak-chip">
                    <span class="chip-label">最近峰值</span>
                    <span class="chip-value mono" id="disk-peak">0.0 MB/s</span>
                  </div>
                </div>
                <div class="kv" style="margin-top:6px">
                  <div class="label">活跃度</div>
                  <div class="meter"><i id="disk-activity-bar"></i></div>
                  <div class="mono" id="disk-activity-text">— %</div>
                </div>
              </div>
            </div>
          </div>
          <canvas class="spark" id="disk-spark"></canvas>
        </section>



        <section class="card span-2 temp-card" id="temp-card">
          <div class="temp-header">
            <div>
              <div class="label">温度传感器</div>
              <div class="temp-highlights" id="temp-highlights">
                <div class="temp-chip">
                  <div class="label">CPU 封装</div>
                  <div class="value mono">—</div>
                </div>
                <div class="temp-chip">
                  <div class="label">CPU 核心</div>
                  <div class="value mono">—</div>
                </div>
                <div class="temp-chip">
                  <div class="label">主板</div>
                  <div class="value mono">—</div>
                </div>
              </div>
            </div>
            <button class="temp-toggle" id="temp-toggle">展开</button>
          </div>
          <!-- Top hottest sensors preview (collapsed only) -->
          <div class="temp-mini-grid" id="temp-mini-grid"></div>
          <div class="temp-list-wrapper">
            <ul class="temp-list" id="temp-list"></ul>
          </div>
        </section>
      </main>

      <!-- <aside class="alerts-panel" id="alerts-panel">
        <div class="panel-card">
          <div>
            <div class="panel-title">告警</div>
            <div class="panel-subtitle">实时监控</div>
          </div>
          <div class="alert-body" id="alert-list">
            <div class="alert-empty">当前无告警</div>
          </div>
        </div>
      </aside> -->
    </div>

    <footer>
      <div id="source" class="subtitle">数据源：LibreHardwareMonitor</div>
      <div class="mono" id="ver">—</div>
    </footer>
  </div>

  <!-- Settings Modal -->
  <div id="global-light"></div>
  <div class="modal-overlay" id="settings-modal">
    <div class="modal">
      <div class="modal-header">
        <div class="modal-title">光效设置</div>
        <button class="modal-close" id="modal-close">&times;</button>
      </div>
      <div class="modal-body">
        <div class="control-row">
          <div class="label">自动变色</div>
          <label class="switch">
            <input type="checkbox" id="auto-color-toggle" checked>
            <span class="slider"></span>
          </label>
        </div>
        <div class="control-row">
          <div class="label">手动颜色</div>
          <input type="color" id="manual-color-picker" value="#00f2ff" disabled style="background:none; border:none; width:40px; height:40px; cursor:pointer;">
        </div>
        <div class="control-row">
          <div class="label">渲染模式</div>
          <select id="render-mode-select">
            <option value="webgl">WebGL (高性能)</option>
            <option value="css">CSS (兼容模式)</option>
          </select>
        </div>
        <div class="control-row" id="render-scale-row">
          <div class="label">渲染分辨率 <span id="render-scale-val" class="mono" style="font-size:12px; opacity:0.7; margin-left:4px">1.0x</span></div>
          <input type="range" id="render-scale-slider" min="0.25" max="1.5" step="0.25" value="1.0" style="width: 120px; cursor: pointer;">
        </div>
        <div class="control-row">
          <div class="label">光照强度 <span id="intensity-val" class="mono" style="font-size:12px; opacity:0.7; margin-left:4px">1000 lm</span></div>
          <input type="range" id="intensity-slider" min="0" max="2" step="0.1" value="1" style="width: 120px; cursor: pointer;">
        </div>
        <div class="control-row">
          <div class="label">光照范围 <span id="range-val" class="mono" style="font-size:12px; opacity:0.7; margin-left:4px">100%</span></div>
          <input type="range" id="range-slider" min="0.5" max="2" step="0.1" value="1" style="width: 120px; cursor: pointer;">
        </div>
        <div class="control-row">
          <div class="label">云层交互</div>
          <label class="switch">
            <input type="checkbox" id="cloud-interaction-toggle" checked>
            <span class="slider"></span>
          </label>
        </div>
        <div class="control-row">
          <div class="label">特效质量</div>
          <select id="quality-select">
            <option value="high">高 (流畅)</option>
            <option value="balanced">中 (平衡)</option>
            <option value="low">低 (节能)</option>
          </select>
        </div>
        <div class="control-row">
          <div class="label">主题风格</div>
          <select id="theme-select">
            <option value="default">默认 (午夜)</option>
            <option value="cyberpunk">赛博朋克</option>
            <option value="forest">幽暗森林</option>
            <option value="sunset">暮光之城</option>
          </select>
        </div>
        <div style="height:1px; background:var(--card-border); margin: 8px 0;"></div>
        <div class="control-row">
          <div class="label">禁用云层动画</div>
          <label class="switch">
            <input type="checkbox" id="disable-clouds-toggle">
            <span class="slider"></span>
          </label>
        </div>
        <div class="control-row">
          <div class="label">禁用动态光照</div>
          <label class="switch">
            <input type="checkbox" id="disable-light-toggle">
            <span class="slider"></span>
          </label>
        </div>
        <div class="control-row">
          <div class="label">采集频率 <span id="refresh-rate-val" class="mono" style="font-size:12px; opacity:0.7; margin-left:4px">2.0s</span></div>
          <input type="range" id="refresh-rate-slider" min="0.5" max="10" step="0.5" value="2" style="width: 120px; cursor: pointer;">
        </div>
      </div>
    </div>
  </div>

  <script>
    const $ = (s)=>document.querySelector(s);
    const setText = (id, v)=>{ 
      const el=$(id); 
      if(el && el.textContent !== String(v)) el.textContent = v 
    };
    function clamp(n,min,max){ return Math.max(min, Math.min(max, n)) }
    function hexToRgba(hex, alpha) {
      const r = parseInt(hex.slice(1, 3), 16);
      const g = parseInt(hex.slice(3, 5), 16);
      const b = parseInt(hex.slice(5, 7), 16);
      return `rgba(${r}, ${g}, ${b}, ${alpha})`;
    }

    class Spark{
      constructor(canvas, capacity=120, yMaxHint=100, color='#00f2ff'){
        this.c = canvas; this.ctx = canvas.getContext('2d');
        this.buf = []; this.capacity = capacity; this.yMaxHint = yMaxHint;
        this.color = color;
        this.colorRgbaStart = hexToRgba(this.color, 0.25);
        this.colorRgbaEnd = hexToRgba(this.color, 0);
        
        this.resize();
      }
      
      resize() {
        const dpr = Math.max(1, window.devicePixelRatio||1);
        const rect = this.c.getBoundingClientRect();
        // Cache dimensions to avoid layout thrashing during draw
        this.w = rect.width;
        this.h = rect.height;
        
        // Only resize canvas if dimensions actually changed to avoid clearing content unnecessarily
        if (this.c.width !== rect.width * dpr || this.c.height !== rect.height * dpr) {
          this.c.width = rect.width * dpr; 
          this.c.height = rect.height * dpr;
          this.ctx.scale(dpr, dpr);
          this.draw(); // Redraw after resize
        }
      }

      push(v){
        this.buf.push(v ?? 0); if(this.buf.length>this.capacity) this.buf.shift();
        this.draw();
      }
      
      draw(){
        // Use cached dimensions
        const w = this.w;
        const h = this.h;
        const ctx=this.ctx; 
        ctx.clearRect(0,0,w,h);
        
        // Grid lines
        ctx.strokeStyle = 'rgba(255,255,255,0.03)';
        ctx.lineWidth = 1; ctx.beginPath();
        for(let y=h; y>=0; y-=16){ ctx.moveTo(0,y); ctx.lineTo(w,y); } 
        ctx.stroke();
        
        if(this.buf.length<2) return;
        const max = Math.max(this.yMaxHint, ...this.buf, 1);
        
        ctx.beginPath();
        ctx.strokeStyle = this.color;
        ctx.lineWidth = 3; ctx.lineJoin='round'; ctx.lineCap='round';
        
        // Draw line
        const step = w / (this.capacity - 1);
        
        for(let i=0; i<this.buf.length; i++){
          const x = i * step;
          const val = this.buf[i];
          const y = h - (val/max)*h;
          if(i===0) ctx.moveTo(x,y);
          else ctx.lineTo(x,y);
        }
        ctx.stroke();
        
        // Fill
        ctx.lineTo(this.buf.length * step, h);
        ctx.lineTo(0, h);
        ctx.closePath();
        
        const grad = ctx.createLinearGradient(0, 0, 0, h);
        grad.addColorStop(0, this.colorRgbaStart);
        grad.addColorStop(1, this.colorRgbaEnd);
        ctx.fillStyle = grad; 
        ctx.fill();
      }
    }

    function setRing(el, percent){
      if(!el) return;
      percent = clamp(percent ?? 0, 0, 100);
      const newP = Math.round(percent);
      if (el._lastP === newP) return;
      el._lastP = newP;
      el.style.setProperty('--p', percent);
      el.querySelector('span').textContent = newP + '%';
    }
    function setMeter(el, percent){
      if(!el) return;
      const pct = clamp(percent ?? 0,0,100);
      if (el._lastPct === pct) return;
      el._lastPct = pct;
      el.style.width = pct + '%';
    }

    function setChipText(chipEl, text){
      if(!chipEl) return;
      const value = text && text.trim().length ? text : '—';
      if (chipEl._lastText === value) return;
      chipEl._lastText = value;

      chipEl.classList.remove('marquee');
      chipEl.innerHTML = `<span>${value}</span>`;
      requestAnimationFrame(() => {
        const span = chipEl.querySelector('span');
        if(!span) return;
        if(span.scrollWidth > chipEl.clientWidth){
          chipEl.classList.add('marquee');
          chipEl.innerHTML = `<div class="marquee-track"><span>${value}</span><span>${value}</span></div>`;
        }
      });
    }

    function setTitleText(el, text){
      if(!el) return;
      const value = (text ?? '—').toString();
      if (el.textContent === value) return;
      el.classList.remove('marquee');
      el.textContent = value;
      if(value === '—'){
        el.removeAttribute('title');
      } else {
        el.title = value;
      }
    }

    const cpuSpark = new Spark($('#cpu-spark'), 120, 100, '#00f2ff');
    const gpuSpark = new Spark($('#gpu-spark'), 120, 100, '#ff8c00');
    const memSpark = new Spark($('#mem-spark'), 120, 100, '#00e676');
    const netSpark = new Spark($('#net-spark'), 120, 20, '#00f2ff');
    const diskSpark= new Spark($('#disk-spark'),120, 20, '#00f2ff');
    
    const allSparks = [cpuSpark, gpuSpark, memSpark, netSpark, diskSpark];
    
    const cpuRingEl = document.getElementById('cpu-ring');
    const gpuRingEl = document.getElementById('gpu-ring');
    const cpuTempBar = document.getElementById('cpu-temp-bar');
    const cpuClockBar = document.getElementById('cpu-clock-bar');
    const gpuTempBar = document.getElementById('gpu-temp-bar');
    const gpuClockBar = document.getElementById('gpu-clock-bar');
    const gpuMemoryBar = document.getElementById('gpu-memory-bar');
    const memRingEl = document.getElementById('mem-ring');
    const memPressureEl = document.getElementById('mem-pressure');
    const memPressureChip = document.getElementById('mem-pressure-chip');
    // const alertsPanel = document.getElementById('alerts-panel');
    const alertListEl = document.getElementById('alert-list');
    const cpuNameChip = document.getElementById('cpu-name-chip');
    const gpuNameChip = document.getElementById('gpu-name-chip');
  const netNameChip = document.getElementById('net-name-chip');
  const netLinkChip = document.getElementById('net-link-chip');
  const netIpListEl = document.getElementById('net-ip-list');
    const gpuPrevBtn = document.getElementById('gpu-prev');
    const gpuNextBtn = document.getElementById('gpu-next');
    const netPrevBtn = document.getElementById('net-prev');
    const netNextBtn = document.getElementById('net-next');
    const tempCard = document.getElementById('temp-card');
    const tempToggleBtn = document.getElementById('temp-toggle');
    const tempListEl = document.getElementById('temp-list');
    const tempHighlightsEl = document.getElementById('temp-highlights');
  const tempMiniGridEl = document.getElementById('temp-mini-grid');
    let tempCardBaseHeight = 140;
    const updateTempCardBaseHeight = () => {
      if(tempCard.classList.contains('expanded')) return tempCardBaseHeight;
      const measured = Math.max(tempCard.offsetHeight, 140);
      tempCardBaseHeight = measured;
      tempCard.style.setProperty('--temp-card-base-height', `${Math.round(measured)}px`);
      return measured;
    };
    updateTempCardBaseHeight();
    window.addEventListener('resize', () => {
      updateTempCardBaseHeight();
      allSparks.forEach(s => s.resize());
    });
    
    const fgAppNameEl = document.getElementById('fg-app-name');
    const fgProcessNameEl = document.getElementById('fg-process-name');
    const fgCpuBar = document.getElementById('fg-cpu-bar');
    const fgCpuTextEl = document.getElementById('fg-cpu');
    const fgMemBar = document.getElementById('fg-mem-bar');
    const fgMemTextEl = document.getElementById('fg-mem');
  const fgTopListEl = document.getElementById('fg-top-list');
  // Disk UI extras
  const diskActivityBar = document.getElementById('disk-activity-bar');
  const diskActivityText = document.getElementById('disk-activity-text');
  const diskTotalTextEl = document.getElementById('disk-total');
  const diskRwRatioEl = document.getElementById('disk-rw-ratio');
  const diskPeakTextEl = document.getElementById('disk-peak');

    let netList = [];
    let netIndex = 0;
    let netSummary = null;
    let gpuList = [];
    let gpuIndex = 0;
    let latestTemps = [];
    let tempHighlights = [];
    let totalMemoryGb = 0;
  // rolling history for disk total throughput (MB/s)
  const diskHistory = [];
  const diskHistoryCap = 120;

    setInterval(()=>{
      const d=new Date();
      setText('#clock', d.toLocaleTimeString());
    }, 1000);

    if(netPrevBtn){ netPrevBtn.disabled = true; }
    if(netNextBtn){ netNextBtn.disabled = true; }

    gpuPrevBtn.addEventListener('click', ()=>switchGpu(-1));
    gpuNextBtn.addEventListener('click', ()=>switchGpu(1));
    if(netPrevBtn){ netPrevBtn.addEventListener('click', ()=>switchNet(-1)); }
    if(netNextBtn){ netNextBtn.addEventListener('click', ()=>switchNet(1)); }
    tempToggleBtn.addEventListener('click', ()=>{
      const willExpand = !tempCard.classList.contains('expanded');
      if(willExpand){
        updateTempCardBaseHeight();
        tempCard.classList.add('expanded');
        tempToggleBtn.textContent = '收起';
      } else {
        tempCard.classList.remove('expanded');
        tempToggleBtn.textContent = '展开';
        setTimeout(updateTempCardBaseHeight, 320);
      }
      renderTempList();
    });

    function switchGpu(step){
      if(!gpuList.length) return;
      gpuIndex = (gpuIndex + step + gpuList.length) % gpuList.length;
      renderGpuCard(false);
    }

    function renderGpuCard(push){
      const gpu = gpuList[gpuIndex] ?? null;
      gpuPrevBtn.disabled = gpuList.length <= 1;
      gpuNextBtn.disabled = gpuList.length <= 1;

      if(gpu){
        setChipText(gpuNameChip, gpu.name || `GPU ${gpuIndex + 1}`);
        const usage = gpu.usage ?? 0;
        setText('#gpu-usage', Math.round(usage) + '%');
        setRing(gpuRingEl, usage);
        const temp = gpu.temp ?? null;
        setText('#gpu-temp', temp != null ? `${temp.toFixed(0)} ℃` : '— ℃');
        setMeter(gpuTempBar, temp != null ? clamp(temp, 0, 110) : 0);
        const clock = gpu.clock ?? null;
        setText('#gpu-clock', clock != null ? `${clock.toFixed(0)} MHz` : '— MHz');
        setMeter(gpuClockBar, clock != null ? clamp(clock / 3000 * 100, 0, 100) : 0);
        const memoryUsed = typeof gpu.memoryUsed === 'number' && !Number.isNaN(gpu.memoryUsed) ? gpu.memoryUsed : null;
        const memoryTotal = typeof gpu.memoryTotal === 'number' && !Number.isNaN(gpu.memoryTotal) ? gpu.memoryTotal : null;
  // Debug log removed; use DevTools if needed to inspect gpu object
        let memoryPct = typeof gpu.memoryUsage === 'number' && !Number.isNaN(gpu.memoryUsage) ? gpu.memoryUsage : null;
        if(memoryPct == null && memoryUsed != null && memoryTotal != null && memoryTotal > 0){
          memoryPct = memoryUsed / memoryTotal * 100;
        }
        let memoryText = '—';
        if(memoryUsed != null && memoryTotal != null && memoryTotal > 0){
          const usedText = memoryUsed >= 10 ? memoryUsed.toFixed(0) : memoryUsed.toFixed(1);
          const totalText = memoryTotal >= 10 ? memoryTotal.toFixed(0) : memoryTotal.toFixed(1);
          memoryText = `${usedText} / ${totalText} GB`;
          if(memoryPct != null){
            memoryText += ` (${Math.round(memoryPct)}%)`;
          }
        } else if(memoryPct != null){
          memoryText = `${Math.round(memoryPct)}%`;
        } else if(memoryUsed != null){
          memoryText = `${memoryUsed.toFixed(1)} GB`;
        }
        setText('#gpu-memory', memoryText);
        setMeter(gpuMemoryBar, memoryPct != null ? clamp(memoryPct, 0, 100) : 0);
        if(push) gpuSpark.push(usage);
      } else {
        setChipText(gpuNameChip, '—');
        setText('#gpu-usage', '—');
        setRing(gpuRingEl, 0);
        if(gpuRingEl){ gpuRingEl.querySelector('span').textContent = '—'; }
        setText('#gpu-temp', '— ℃');
        setMeter(gpuTempBar, 0);
        setText('#gpu-clock', '— MHz');
        setMeter(gpuClockBar, 0);
        setText('#gpu-memory', '—');
        setMeter(gpuMemoryBar, 0);
        if(push) gpuSpark.push(0);
      }
    }

    function switchNet(step){
      if(!netList.length) return;
      netIndex = (netIndex + step + netList.length) % netList.length;
      renderNetCard(false);
    }

    function renderNetCard(push){
      const adapter = netList[netIndex] ?? null;

      if(netPrevBtn){ netPrevBtn.disabled = netList.length <= 1; }
      if(netNextBtn){ netNextBtn.disabled = netList.length <= 1; }

      if(adapter){
        setChipText(netNameChip, adapter.name || `网卡 ${netIndex + 1}`);
        const up = typeof adapter.upMBps === 'number' && !Number.isNaN(adapter.upMBps) ? adapter.upMBps : 0;
        const down = typeof adapter.downMBps === 'number' && !Number.isNaN(adapter.downMBps) ? adapter.downMBps : 0;
        setText('#net-up', up.toFixed(1));
        setText('#net-down', down.toFixed(1));
        // link meta
        const linkMbps = typeof adapter.linkSpeedMbps === 'number' && isFinite(adapter.linkSpeedMbps) ? adapter.linkSpeedMbps : null;
        const typeText = adapter.connectionType === 'wireless' ? '无线' : (adapter.connectionType === 'wired' ? '有线' : null);
        let speedText = null;
        if(linkMbps != null){
          speedText = linkMbps >= 1000 ? `${(linkMbps/1000).toFixed(1)} Gbps` : `${Math.round(linkMbps)} Mbps`;
        }
        const metaText = typeText && speedText ? `${typeText} · ${speedText}` : (typeText || speedText || '—');
        if(netLinkChip){ setChipText(netLinkChip, metaText); }
        const ips = Array.isArray(adapter.ips) ? adapter.ips : (Array.isArray(adapter.ipAddresses) ? adapter.ipAddresses : []);
        renderNetIps(ips);
        if(push) netSpark.push(up + down);
        return;
      }

      if(netPrevBtn){ netPrevBtn.disabled = true; }
      if(netNextBtn){ netNextBtn.disabled = true; }
  setChipText(netNameChip, '—');
  if(netLinkChip){ setChipText(netLinkChip, '—'); }
  renderNetIps([]);

      const fallbackUp = netSummary && typeof netSummary.upMBps === 'number' && !Number.isNaN(netSummary.upMBps) ? netSummary.upMBps : 0;
      const fallbackDown = netSummary && typeof netSummary.downMBps === 'number' && !Number.isNaN(netSummary.downMBps) ? netSummary.downMBps : 0;
      setText('#net-up', fallbackUp.toFixed(1));
      setText('#net-down', fallbackDown.toFixed(1));
      if(push) netSpark.push(fallbackUp + fallbackDown);
    }

    function renderNetIps(ips){
      if(!netIpListEl) return;
      const list = Array.isArray(ips) ? ips.filter(ip => typeof ip === 'string' && ip.length) : [];
      const maxChips = 3;
      const shown = list.slice(0, maxChips);
      const extra = list.length - shown.length;
      netIpListEl.innerHTML = '&nbsp;IP:';
      const frag = document.createDocumentFragment();
      shown.forEach(ip => {
        const chip = document.createElement('div');
        chip.className = 'chip small ip-chip';
        chip.textContent = ip;
        chip.title = '点击复制';
        chip.addEventListener('click', async () => {
          try{
            await navigator.clipboard?.writeText(ip);
            const prev = chip.textContent;
            chip.textContent = '已复制';
            setTimeout(()=>{ chip.textContent = prev; }, 800);
          }catch{}
        }, { once: false });
        frag.appendChild(chip);
      });
      if(extra > 0){
        const more = document.createElement('div');
        more.className = 'chip small';
        more.textContent = `+${extra}`;
        frag.appendChild(more);
      }
      netIpListEl.appendChild(frag);
    }

function renderTempHighlights(){
  if(!tempHighlightsEl) return;

  const highlights = tempHighlights
    .filter(h => typeof h.valueC === 'number')
    .map(h => ({ label: h.label, value: h.valueC }))
    .slice(0, 3);

  if(!highlights.length){
    tempHighlightsEl.innerHTML = `
      <div class="temp-chip">
        <div class="label">无可用数据</div>
        <div class="value mono">—</div>
      </div>`;
    return;
  }

  tempHighlightsEl.innerHTML = highlights
    .map(item => `
      <div class="temp-chip">
        <div class="label">${item.label}</div>
        <div class="value mono">${item.value.toFixed(1)} ℃</div>
      </div>`)
    .join("");
}

function renderTempList(){
  if(!latestTemps.length){
    renderTempHighlights();
    renderTempMiniGrid();
    if(tempCard.classList.contains('expanded')){
      tempListEl.innerHTML = '';
    }
    return;
  }

  renderTempHighlights();
  renderTempMiniGrid();

  if(!tempCard.classList.contains('expanded')){
    return;
  }

  const orderedTemps = [...latestTemps].sort((a,b) => (b.valueC ?? -Infinity) - (a.valueC ?? -Infinity));

  tempListEl.innerHTML = orderedTemps
    .map(entry => {
      const value = entry.valueC != null ? `${entry.valueC.toFixed(1)} ℃` : '—';
      return `<li class="temp-item"><span>${entry.hardware} · ${entry.sensor}</span><span class="mono">${value}</span></li>`;
    })
    .join('');
}

function getTempSeverityClass(c){
  if(c == null || !isFinite(c)) return '';
  if(c >= 80) return 'bad';
  if(c >= 60) return 'warn';
  return 'good';
}

function renderTempMiniGrid(){
  if(!tempMiniGridEl){ return; }
  const temps = Array.isArray(latestTemps) ? latestTemps.filter(t => typeof t.valueC === 'number' && isFinite(t.valueC)) : [];
  if(!temps.length){ tempMiniGridEl.innerHTML = ''; return; }

  // Build items: use top 6 hottest unique labels
  const items = [...temps]
    .map(t => ({ label: `${t.hardware} · ${t.sensor}`, value: t.valueC }))
    .sort((a,b) => b.value - a.value);

  const seen = new Set();
  const top = [];
  for(const it of items){
    const key = it.label.toLowerCase();
    if(seen.has(key)) continue;
    seen.add(key);
    top.push(it);
    if(top.length >= 3) break;
  }

  const html = top.map(it => {
    const pct = clamp((it.value / 100) * 100, 0, 100);
    const sev = getTempSeverityClass(it.value);
    return `<div class="mini-chip ${sev}">
      <div class="label" title="${it.label}">${it.label}</div>
      <div class="value mono">${it.value.toFixed(1)} ℃</div>
      <div class="mini-bar"><i style="width:${pct}%"></i></div>
    </div>`;
  }).join('');
  tempMiniGridEl.innerHTML = html;
}

function formatDuration(totalSeconds){
  totalSeconds = Math.max(0, Math.floor(totalSeconds||0));
  const h = Math.floor(totalSeconds/3600);
  const m = Math.floor((totalSeconds%3600)/60);
  const s = totalSeconds%60;
  const pad = n => n.toString().padStart(2,'0');
  return h>0 ? `${h}:${pad(m)}:${pad(s)}` : `${m}:${pad(s)}`;
}

function renderTopForegroundApps(list){
  if(!fgTopListEl) return;
  const arr = Array.isArray(list) ? list.slice(0,3) : [];
  fgTopListEl.innerHTML = '';
  if(arr.length === 0){ return; }
  const fragment = document.createDocumentFragment();
  arr.forEach(it => {
    const name = it.displayTitle || it.name || '—';
    const dur = formatDuration(it.totalSeconds || 0);

    const chip = document.createElement('div');
    chip.className = 'chip small';

    const labelSpan = document.createElement('span');
    labelSpan.className = 'chip-label';
    labelSpan.textContent = '累计';

    const valueSpan = document.createElement('span');
    valueSpan.className = 'chip-value';
    valueSpan.textContent = dur;

    const separator = document.createElement('span');
    separator.style.opacity = '.6';
    separator.textContent = ' · ';

    const nameSpan = document.createElement('span');
    nameSpan.className = 'mono fg-chip-name';
    nameSpan.textContent = name;
    if(name && name !== '—'){
      nameSpan.title = name;
    }

    chip.append(labelSpan, valueSpan, separator, nameSpan);
    fragment.appendChild(chip);
  });
  fgTopListEl.appendChild(fragment);
}

    window.updateMetrics = function(m){
      if(m.cpu){
        const usage = m.cpu.usage ?? 0;
        setText('#cpu-usage', Math.round(usage)+'%');
        setRing(cpuRingEl, usage);
        const temp = m.cpu.temp ?? null;
        setText('#cpu-temp', temp!=null ? `${temp.toFixed(0)} ℃` : '— ℃');
        setMeter(cpuTempBar, temp!=null ? clamp(temp,0,100) : 0);
        const clock = m.cpu.clock ?? null;
        setText('#cpu-clock', clock!=null ? `${clock.toFixed(0)} MHz` : '— MHz');
        setMeter(cpuClockBar, clock!=null ? clamp(clock/6000*100,0,100) : 0);
        cpuSpark.push(usage);
        setChipText(cpuNameChip, m.cpu.name ?? '—');
      }
      if(Array.isArray(m.gpus)){
        const currentName = gpuList[gpuIndex]?.name;
        const prioritized = [...m.gpus].sort((a, b) => {
          const aName = a?.name ?? '';
          const bName = b?.name ?? '';
          const aIsNvidia = /nvidia/i.test(aName);
          const bIsNvidia = /nvidia/i.test(bName);
          if(aIsNvidia === bIsNvidia) return 0;
          return aIsNvidia ? -1 : 1;
        });
        gpuList = prioritized;
        if(!gpuList.length){
          gpuIndex = 0;
        } else if(currentName){
          const matchIndex = gpuList.findIndex(g => g.name === currentName);
          gpuIndex = matchIndex >= 0 ? matchIndex : 0;
        } else {
          gpuIndex = 0;
        }
        renderGpuCard(true);
      } else if(!gpuList.length){
        renderGpuCard(true);
      }
      if(m.mem){
        const rawUsed = typeof m.mem.usedGB === 'number' && !Number.isNaN(m.mem.usedGB) ? m.mem.usedGB : null;
        const rawTotal = typeof m.mem.totalGB === 'number' && !Number.isNaN(m.mem.totalGB) ? m.mem.totalGB : null;
        const used = rawUsed != null ? Math.max(rawUsed, 0) : null;
        const total = rawTotal != null ? Math.max(rawTotal, 0) : null;
        const pct = total && used != null && total > 0 ? clamp((used / total) * 100, 0, 100) : null;

        setText('#mem-used', used != null ? used.toFixed(1) : '--');
        setText('#mem-total', total != null ? total.toFixed(1) : '--');
        memSpark.push(pct ?? 0);
        if(total != null && total > 0){
          totalMemoryGb = total;
        }

        if(memRingEl){
          if(pct != null){
            setRing(memRingEl, pct);
          } else {
            memRingEl.style.setProperty('--p', 0);
            const span = memRingEl.querySelector('span');
            if(span) span.textContent = '--';
          }
        }

        const speed = typeof m.mem.speedMhz === 'number' && !Number.isNaN(m.mem.speedMhz) ? m.mem.speedMhz : null;
        setText('#mem-speed', speed != null ? `${Math.round(speed)} MHz` : '-- MHz');

        if(memPressureEl){
          let pressureLabel = '--';
          let pressureClass = null;
          if(pct != null){
            if(pct >= 90){
              pressureLabel = '告警';
              pressureClass = 'bad';
            } else if(pct >= 75){
              pressureLabel = '偏高';
              pressureClass = 'warn';
            } else {
              pressureLabel = '正常';
              pressureClass = 'good';
            }
          }
          memPressureEl.textContent = pressureLabel;
          if(memPressureChip){
            memPressureChip.classList.remove('good','warn','bad');
            if(pressureClass){
              memPressureChip.classList.add(pressureClass);
            }
          }
        }
      } else {
        setText('#mem-used', '--');
        setText('#mem-total', '--');
        memSpark.push(0);
        if(memRingEl){
          memRingEl.style.setProperty('--p', 0);
          const span = memRingEl.querySelector('span');
          if(span) span.textContent = '--';
        }
        setText('#mem-speed', '-- MHz');
        if(memPressureEl){
          memPressureEl.textContent = '--';
        }
        if(memPressureChip){
          memPressureChip.classList.remove('good','warn','bad');
        }
      }

      if(m.net){
        netSummary = m.net;
      }
      if(Array.isArray(m.netAdapters)){
        const currentId = netList[netIndex]?.id ?? null;
        netList = m.netAdapters;
        if(!netList.length){
          netIndex = 0;
        } else if(currentId){
          const matchIndex = netList.findIndex(n => n.id === currentId);
          netIndex = matchIndex >= 0 ? matchIndex : 0;
        } else {
          netIndex = 0;
        }
        renderNetCard(true);
      } else if(m.net){
        netList = [];
        netIndex = 0;
        renderNetCard(true);
      }
      if(m.disk){
        const r = m.disk.readMBps ?? 0;
        const w = m.disk.writeMBps ?? 0;
        setText('#disk-r', r.toFixed(1));
        setText('#disk-w', w.toFixed(1));
        const total = r + w;
        diskSpark.push(total);
        // update extras
        if(diskTotalTextEl){ diskTotalTextEl.textContent = `${total.toFixed(1)} MB/s`; }
        if(diskRwRatioEl){
          if(total > 0){
            const rp = Math.round((r/total)*100);
            const wp = 100 - rp;
            diskRwRatioEl.textContent = `${rp}% / ${wp}%`;
          } else {
            diskRwRatioEl.textContent = '—';
          }
        }
        // maintain rolling peak
        diskHistory.push(total);
        if(diskHistory.length > diskHistoryCap) diskHistory.shift();
        const peak = Math.max(0, ...diskHistory);
        if(diskPeakTextEl){ diskPeakTextEl.textContent = `${peak.toFixed(1)} MB/s`; }
        // activity percent vs rolling peak
        const activity = peak > 0 ? clamp((total/peak)*100, 0, 100) : 0;
        if(diskActivityBar){ setMeter(diskActivityBar, activity); }
        if(diskActivityText){ diskActivityText.textContent = peak > 0 ? `${Math.round(activity)} %` : '— %'; }
      }

      if(m.foregroundApp){
        const app = m.foregroundApp;
        setTitleText(fgAppNameEl, app.windowTitle || app.processName || '—');
        setChipText(fgProcessNameEl, app.processName || '—');

        const cpuUsage = app.cpuUsagePercentage ?? null;
        if(cpuUsage != null){
          fgCpuTextEl.textContent = `${cpuUsage.toFixed(1)} %`;
          setMeter(fgCpuBar, clamp(cpuUsage, 0, 100));
          // no extra chips now
        } else {
          fgCpuTextEl.textContent = '— %';
          setMeter(fgCpuBar, 0);
        }

        const memoryMb = app.memoryUsageMb ?? null;
        if(memoryMb != null){
          const display = memoryMb >= 1024 ? `${(memoryMb/1024).toFixed(1)} GB` : `${memoryMb.toFixed(0)} MB`;
          fgMemTextEl.textContent = display;
          const denominatorMb = totalMemoryGb > 0 ? totalMemoryGb * 1024 : 8192;
          const memPct = clamp((memoryMb / denominatorMb) * 100, 0, 100);
          setMeter(fgMemBar, memPct);
          // no extra chips now
        } else {
          fgMemTextEl.textContent = '— MB';
          setMeter(fgMemBar, 0);
        }
      } else {
        setTitleText(fgAppNameEl, '—');
        setChipText(fgProcessNameEl, '—');
        fgCpuTextEl.textContent = '— %';
        fgMemTextEl.textContent = '— MB';
        setMeter(fgCpuBar, 0);
        setMeter(fgMemBar, 0);
      }

      if(Array.isArray(m.topForegroundApps)){
        renderTopForegroundApps(m.topForegroundApps);
      }

      // const alerts=[];
      // if(m.cpu?.temp>85) alerts.push(`CPU 温度过高：${m.cpu.temp.toFixed(0)}℃`);
      // const activeGpu = gpuList[gpuIndex];
      // if(activeGpu?.temp>85) alerts.push(`GPU 温度过高：${activeGpu.temp.toFixed(0)}℃`);

      // if(alerts.length){
      //   alertsPanel.classList.add('has-alerts');
      //   alertListEl.innerHTML = alerts
      //     .map(a=>`<div class="alert-chip">⚠️ ${a}</div>`)
      //     .join('');
      // }else{
      //   alertsPanel.classList.remove('has-alerts');
      //   alertListEl.innerHTML = `<div class="alert-empty">当前无告警</div>`;
      // }

      tempHighlights = Array.isArray(m.temperatureHighlights) ? m.temperatureHighlights : [];
      latestTemps = Array.isArray(m.temperatures) ? m.temperatures : [];

      renderTempList();
    }

    async function fetchMetrics(){
      try{
        const res = await fetch('/api/metrics', { cache: 'no-store' });
        if(!res.ok) throw new Error(`HTTP ${res.status}`);
        const snapshot = await res.json();

        if(snapshot.machineName){
          const hostDetail = [snapshot.machineName, snapshot.osVersion, snapshot.motherboard].filter(Boolean).join(' · ');
          setText('#host', hostDetail);
        }

        if(snapshot.timestamp){
          const time = new Date(snapshot.timestamp);
          setText('#ver', `采集 ${time.toLocaleTimeString()}`);
        }

        const cpu = snapshot.cpu ?? {};
        const gpus = Array.isArray(snapshot.gpus) ? snapshot.gpus : [];
        const mem = snapshot.memory ?? {};
        const net = snapshot.network ?? {};
        const netAdapters = Array.isArray(snapshot.networkAdapters) ? snapshot.networkAdapters : [];
        const disk = snapshot.disk ?? {};
        const temps = Array.isArray(snapshot.temperatures) ? snapshot.temperatures : [];
        const tempHighlightsData = Array.isArray(snapshot.temperatureHighlights) ? snapshot.temperatureHighlights : [];

        window.updateMetrics({
          cpu: {
            name: snapshot.cpu?.name ?? null,
            usage: cpu.totalLoadPercentage ?? 0,
            temp: cpu.packageTemperatureC ?? null,
            clock: cpu.clockMhz ?? null
          },
          gpus: gpus.map(gpu => ({
            name: gpu.name ?? '',
            usage: gpu.loadPercentage ?? 0,
            temp: gpu.temperatureC ?? null,
            clock: gpu.coreClockMhz ?? null,
            memoryUsed: gpu.memoryUsedGb ?? null,
            memoryTotal: gpu.memoryTotalGb ?? null,
            memoryUsage: gpu.memoryUsagePercentage ?? null
          })),
          mem: {
            usedGB: mem.usedGb ?? null,
            totalGB: mem.totalGb ?? null,
            speedMhz: mem.speedMhz ?? null
          },
          net: {
            upMBps: net.uploadMBps ?? 0,
            downMBps: net.downloadMBps ?? 0
          },
          netAdapters: netAdapters.map(adapter => ({
            id: adapter.identifier ?? '',
            name: adapter.name ?? '',
            upMBps: adapter.uploadMBps ?? null,
            downMBps: adapter.downloadMBps ?? null,
            linkSpeedMbps: adapter.linkSpeedMbps ?? null,
            connectionType: adapter.connectionType ?? null,
            ips: Array.isArray(adapter.ipAddresses) ? adapter.ipAddresses : []
          })),
          disk: {
            readMBps: disk.readMbps ?? 0,
            writeMBps: disk.writeMbps ?? 0
          },
          temperatures: temps,
          temperatureHighlights: tempHighlightsData,
          foregroundApp: snapshot.foregroundApp ?? null,
          topForegroundApps: Array.isArray(snapshot.topForegroundApps) ? snapshot.topForegroundApps : []
        });
      }catch(err){
        console.error('获取监控数据失败', err);
      }
    }

    setChipText(cpuNameChip, '—');
    setChipText(gpuNameChip, '—');
    setChipText(netNameChip, '—');
    renderTempHighlights();

    fetchMetrics();
    let fetchTimer = setInterval(fetchMetrics, 2000);

    function updateFetchInterval(seconds) {
      clearInterval(fetchTimer);
      fetchTimer = setInterval(fetchMetrics, seconds * 1000);
    }

    // Light Effect Logic
    const cards = document.querySelectorAll('.card');
    let time = 0;
    
    // State
    let isAutoColor = true;
    let manualColorHex = '#00f2ff';
    let manualColorRgb = '0, 242, 255';
    let mouseX = 0, mouseY = 0;
    let isMouseInWindow = false;
    let lastMouseMoveTime = 0;
    let refreshRate = 2.0;
    let effectQuality = 'high'; // 'high', 'balanced', 'low'

    // UI Elements
    const clockBtn = document.getElementById('clock');
    const modalOverlay = document.getElementById('settings-modal');
    const modalCloseBtn = document.getElementById('modal-close');
    const autoColorToggle = document.getElementById('auto-color-toggle');
    const manualColorPicker = document.getElementById('manual-color-picker');
    const intensitySlider = document.getElementById('intensity-slider');
    const intensityVal = document.getElementById('intensity-val');
    const rangeSlider = document.getElementById('range-slider');
    const rangeVal = document.getElementById('range-val');
    const cloudInteractionToggle = document.getElementById('cloud-interaction-toggle');
    const qualitySelect = document.getElementById('quality-select');
    const themeSelect = document.getElementById('theme-select');
    const disableCloudsToggle = document.getElementById('disable-clouds-toggle');
    const disableLightToggle = document.getElementById('disable-light-toggle');
    const refreshRateSlider = document.getElementById('refresh-rate-slider');
    const refreshRateVal = document.getElementById('refresh-rate-val');

    // Persistence
    function saveSettings() {
      const settings = {
        isAutoColor,
        manualColorHex,
        intensity: intensitySlider.value,
        range: rangeSlider.value,
        cloudInteraction: cloudInteractionToggle.checked,
        quality: qualitySelect.value,
        theme: themeSelect.value,
        disableClouds: disableCloudsToggle.checked,
        disableLight: disableLightToggle.checked,
        refreshRate: refreshRateSlider.value,
        renderMode: renderModeSelect.value,
        renderScale: renderScaleSlider.value
      };
      localStorage.setItem('monitor_settings', JSON.stringify(settings));
    }

    function loadSettings() {
      try {
        const raw = localStorage.getItem('monitor_settings');
        if (!raw) return;
        const s = JSON.parse(raw);

        if (s.isAutoColor !== undefined) {
          isAutoColor = s.isAutoColor;
          autoColorToggle.checked = isAutoColor;
          manualColorPicker.disabled = isAutoColor;
        }
        if (s.manualColorHex) {
          manualColorHex = s.manualColorHex;
          manualColorPicker.value = manualColorHex;
          const r = parseInt(manualColorHex.slice(1, 3), 16);
          const g = parseInt(manualColorHex.slice(3, 5), 16);
          const b = parseInt(manualColorHex.slice(5, 7), 16);
          manualColorRgb = `${r}, ${g}, ${b}`;
        }
        if (s.intensity) {
          intensitySlider.value = s.intensity;
          intensityVal.textContent = Math.round(s.intensity * 1000) + ' lm';
          document.documentElement.style.setProperty('--light-intensity', s.intensity);
        }
        if (s.range) {
          rangeSlider.value = s.range;
          rangeVal.textContent = Math.round(s.range * 100) + '%';
          document.documentElement.style.setProperty('--light-range-scale', s.range);
        }
        if (s.cloudInteraction !== undefined) {
          cloudInteractionToggle.checked = s.cloudInteraction;
          if (s.cloudInteraction) document.body.classList.add('cloud-interaction');
          else document.body.classList.remove('cloud-interaction');
        } else {
          // Default on
          document.body.classList.add('cloud-interaction');
        }
        if (s.quality) {
          qualitySelect.value = s.quality;
          effectQuality = s.quality;
        }
        if (s.theme) {
          themeSelect.value = s.theme;
          if (s.theme === 'default') document.body.removeAttribute('data-theme');
          else document.body.setAttribute('data-theme', s.theme);
        }
        if (s.disableClouds !== undefined) {
          disableCloudsToggle.checked = s.disableClouds;
          if (s.disableClouds) document.body.classList.add('static-clouds');
          else document.body.classList.remove('static-clouds');
        }
        if (s.disableLight !== undefined) {
          disableLightToggle.checked = s.disableLight;
          isLightDisabled = s.disableLight;
        }
        if (s.refreshRate) {
          refreshRate = parseFloat(s.refreshRate);
          refreshRateSlider.value = refreshRate;
          refreshRateVal.textContent = refreshRate.toFixed(1) + 's';
          updateFetchInterval(refreshRate);
        }
        if (s.renderMode) {
          renderModeSelect.value = s.renderMode;
          setRenderMode(s.renderMode);
        }
        if (s.renderScale) {
          renderScale = parseFloat(s.renderScale);
          renderScaleSlider.value = renderScale;
          renderScaleVal.textContent = renderScale.toFixed(2) + 'x';
          resizeWebGL();
        }
      } catch (e) {
        console.error('Failed to load settings', e);
      }
    }

    // Event Listeners
    window.addEventListener('mousemove', (e) => {
      mouseX = e.clientX;
      mouseY = e.clientY;
      isMouseInWindow = true;
      lastMouseMoveTime = performance.now();
    });
    document.addEventListener('mouseleave', () => {
      isMouseInWindow = false;
    });

    clockBtn.addEventListener('click', () => {
      modalOverlay.classList.add('open');
    });
    modalCloseBtn.addEventListener('click', () => {
      modalOverlay.classList.remove('open');
    });
    modalOverlay.addEventListener('click', (e) => {
      if(e.target === modalOverlay) modalOverlay.classList.remove('open');
    });

    autoColorToggle.addEventListener('change', (e) => {
      isAutoColor = e.target.checked;
      manualColorPicker.disabled = isAutoColor;
      saveSettings();
    });

    manualColorPicker.addEventListener('input', (e) => {
      manualColorHex = e.target.value;
      const r = parseInt(manualColorHex.slice(1, 3), 16);
      const g = parseInt(manualColorHex.slice(3, 5), 16);
      const b = parseInt(manualColorHex.slice(5, 7), 16);
      manualColorRgb = `${r}, ${g}, ${b}`;
      saveSettings();
    });

    intensitySlider.addEventListener('input', (e) => {
      const val = e.target.value;
      intensityVal.textContent = Math.round(val * 1000) + ' lm';
      document.documentElement.style.setProperty('--light-intensity', val);
      saveSettings();
    });

    rangeSlider.addEventListener('input', (e) => {
      const val = e.target.value;
      rangeVal.textContent = Math.round(val * 100) + '%';
      document.documentElement.style.setProperty('--light-range-scale', val);
      saveSettings();
    });

    cloudInteractionToggle.addEventListener('change', (e) => {
      if (e.target.checked) {
        document.body.classList.add('cloud-interaction');
      } else {
        document.body.classList.remove('cloud-interaction');
      }
      saveSettings();
    });

    qualitySelect.addEventListener('change', (e) => {
      effectQuality = e.target.value;
      saveSettings();
    });

    themeSelect.addEventListener('change', (e) => {
      const theme = e.target.value;
      if (theme === 'default') {
        document.body.removeAttribute('data-theme');
      } else {
        document.body.setAttribute('data-theme', theme);
      }
      saveSettings();
    });

    disableCloudsToggle.addEventListener('change', (e) => {
      if (e.target.checked) {
        document.body.classList.add('static-clouds');
      } else {
        document.body.classList.remove('static-clouds');
      }
      saveSettings();
    });

    let isLightDisabled = false;
    disableLightToggle.addEventListener('change', (e) => {
      isLightDisabled = e.target.checked;
      if (!isLightDisabled) {
        requestAnimationFrame(updateLight);
      }
      saveSettings();
    });

    refreshRateSlider.addEventListener('input', (e) => {
      const val = parseFloat(e.target.value);
      refreshRateVal.textContent = val.toFixed(1) + 's';
      updateFetchInterval(val);
      saveSettings();
    });

    // Load settings on startup - Moved to end of script to ensure all vars are defined

    function getSunlightColor() {
      const now = new Date();
      const hour = now.getHours() + now.getMinutes() / 60 + now.getSeconds() / 3600;
      
      // [Hour, R, G, B] - Simulating Day/Night Cycle
      const points = [
        [0, 60, 80, 140],    // Midnight: Cool Moonlight
        [5, 70, 90, 150],    // Pre-dawn
        [6, 255, 100, 60],   // Sunrise: Orange/Red
        [8, 255, 220, 180],  // Morning: Warm
        [12, 255, 255, 255], // Noon: Bright White
        [16, 255, 230, 190], // Afternoon: Golden
        [18, 255, 130, 70],  // Sunset: Deep Orange
        [19.5, 100, 90, 160],// Twilight: Purple
        [21, 60, 80, 140],   // Night: Blue Moonlight
        [24, 60, 80, 140]    // Wrap
      ];

      let p1 = points[0];
      let p2 = points[points.length - 1];
      
      for (let i = 0; i < points.length - 1; i++) {
        if (hour >= points[i][0] && hour < points[i+1][0]) {
          p1 = points[i];
          p2 = points[i+1];
          break;
        }
      }

      const t = (hour - p1[0]) / (p2[0] - p1[0]);
      const r = Math.round(p1[1] + (p2[1] - p1[1]) * t);
      const g = Math.round(p1[2] + (p2[2] - p1[2]) * t);
      const b = Math.round(p1[3] + (p2[3] - p1[3]) * t);
      
      return `${r}, ${g}, ${b}`;
    }

    // WebGL Background Logic
    const glCanvas = document.getElementById('webgl-canvas');
    const renderModeSelect = document.getElementById('render-mode-select');
    const renderScaleSlider = document.getElementById('render-scale-slider');
    const renderScaleVal = document.getElementById('render-scale-val');
    const renderScaleRow = document.getElementById('render-scale-row');

    let gl = null;
    let glProgram = null;
    let glLocations = {};
    let renderScale = 1.0;
    let isWebGLActive = false;

    const VS_SOURCE = `
      attribute vec2 position;
      void main() {
        gl_Position = vec4(position, 0.0, 1.0);
      }
    `;

    const FS_SOURCE = `
      precision mediump float;
      uniform vec2 u_resolution;
      uniform float u_time;
      uniform vec2 u_mouse;
      uniform vec2 u_sun;
      uniform vec3 u_color;
      uniform float u_intensity;
      uniform float u_range;
      uniform float u_opacity; // Controls beam/spot visibility

      // Simple noise function
      float hash(vec2 p) {
        return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);
      }
      float noise(vec2 p) {
        vec2 i = floor(p);
        vec2 f = fract(p);
        f = f * f * (3.0 - 2.0 * f);
        return mix(mix(hash(i), hash(i + vec2(1.0, 0.0)), f.x),
                   mix(hash(i + vec2(0.0, 1.0)), hash(i + vec2(1.0, 1.0)), f.x), f.y);
      }
      float fbm(vec2 p) {
        float v = 0.0;
        float a = 0.5;
        for (int i = 0; i < 3; i++) {
          v += a * noise(p);
          p *= 2.0;
          a *= 0.5;
        }
        return v;
      }

      void main() {
        vec2 uv = gl_FragCoord.xy / u_resolution.xy;
        // Correct aspect ratio for p
        vec2 p = (gl_FragCoord.xy * 2.0 - u_resolution.xy) / min(u_resolution.x, u_resolution.y);
        
        // 1. Background (Transparent/Black)
        // We use CSS background for the main color/gradient to match themes.
        // WebGL only renders lights on top (Overlay blend mode).
        // Clouds are handled by CSS blobs for better color matching.
        
        // 2. Light Calculations
        vec2 sunP = (u_sun * 2.0 - u_resolution.xy) / min(u_resolution.x, u_resolution.y);
        vec2 mouseP = (u_mouse * 2.0 - u_resolution.xy) / min(u_resolution.x, u_resolution.y);
        
        vec2 dir = p - sunP;
        float dist = length(dir);
        float angle = atan(dir.y, dir.x);
        
        vec2 beamDir = normalize(mouseP - sunP);
        float beamAngle = atan(beamDir.y, beamDir.x);
        
        // Wider, softer beam
        float beamWidth = 0.8 * u_range; 
        float beamDiff = abs(angle - beamAngle);
        if (beamDiff > 3.14159) beamDiff = 6.28318 - beamDiff;
        
        float beam = smoothstep(beamWidth, 0.0, beamDiff);
        beam *= smoothstep(2.5, 0.2, dist * 0.8); 
        
        float beamNoiseVal = fbm(vec2(angle * 8.0, dist * 3.0 - u_time * 0.5));
        beam *= 0.9 + 0.1 * beamNoiseVal;

        // 4. Mouse Spot
        float spotDist = length(p - mouseP);
        float spot = smoothstep(0.3 * u_range, 0.0, spotDist);

        // 5. Sun Ambient (Bloom/Scattering)
        float sunDist = length(p - sunP);
        float sunAmbient = smoothstep(1.5 * u_range, 0.0, sunDist); // Larger ambient
        sunAmbient = pow(sunAmbient, 1.5); // Softer falloff

        // Combine Light
        // When opacity is 0 (mouse out), beam and spot disappear, ambient remains
        float lightIntensity = 
          beam * 0.06 * u_intensity * u_opacity +      // Reduced beam
          spot * 0.08 * u_intensity * u_opacity +       // Spot
          sunAmbient * 0.3 * u_intensity;               // Ambient

        vec3 finalColor = u_color * lightIntensity;
        
        // Output with alpha for Overlay blending
        gl_FragColor = vec4(finalColor, clamp(lightIntensity, 0.0, 1.0));
      }
    `;

    function initWebGL() {
      gl = glCanvas.getContext('webgl');
      if (!gl) {
        console.error('WebGL not supported');
        setRenderMode('css');
        return;
      }

      const vs = createShader(gl, gl.VERTEX_SHADER, VS_SOURCE);
      const fs = createShader(gl, gl.FRAGMENT_SHADER, FS_SOURCE);
      glProgram = createProgram(gl, vs, fs);

      glLocations = {
        position: gl.getAttribLocation(glProgram, 'position'),
        u_resolution: gl.getUniformLocation(glProgram, 'u_resolution'),
        u_time: gl.getUniformLocation(glProgram, 'u_time'),
        u_mouse: gl.getUniformLocation(glProgram, 'u_mouse'),
        u_sun: gl.getUniformLocation(glProgram, 'u_sun'),
        u_color: gl.getUniformLocation(glProgram, 'u_color'),
        u_intensity: gl.getUniformLocation(glProgram, 'u_intensity'),
        u_range: gl.getUniformLocation(glProgram, 'u_range'),
        u_opacity: gl.getUniformLocation(glProgram, 'u_opacity')
      };

      const positionBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
        -1, -1,
         1, -1,
        -1,  1,
        -1,  1,
         1, -1,
         1,  1,
      ]), gl.STATIC_DRAW);
    }

    function createShader(gl, type, source) {
      const shader = gl.createShader(type);
      gl.shaderSource(shader, source);
      gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.error(gl.getShaderInfoLog(shader));
        gl.deleteShader(shader);
        return null;
      }
      return shader;
    }

    function createProgram(gl, vs, fs) {
      const program = gl.createProgram();
      gl.attachShader(program, vs);
      gl.attachShader(program, fs);
      gl.linkProgram(program);
      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        console.error(gl.getProgramInfoLog(program));
        return null;
      }
      return program;
    }

    function resizeWebGL() {
      if (!gl) return;
      const w = window.innerWidth * renderScale;
      const h = window.innerHeight * renderScale;
      if (glCanvas.width !== w || glCanvas.height !== h) {
        glCanvas.width = w;
        glCanvas.height = h;
        gl.viewport(0, 0, w, h);
      }
    }

    function renderWebGL(time, sunX, sunY, mouseX, mouseY, colorRgb, intensity, range, opacity) {
      if (!gl || !glProgram) return;
      
      gl.useProgram(glProgram);
      
      gl.enableVertexAttribArray(glLocations.position);
      gl.vertexAttribPointer(glLocations.position, 2, gl.FLOAT, false, 0, 0);

      gl.uniform2f(glLocations.u_resolution, glCanvas.width, glCanvas.height);
      gl.uniform1f(glLocations.u_time, time * 0.001);
      // Adjust mouse/sun coordinates for render scale
      gl.uniform2f(glLocations.u_mouse, mouseX * renderScale, (window.innerHeight - mouseY) * renderScale); // Flip Y for GL
      gl.uniform2f(glLocations.u_sun, sunX * renderScale, (window.innerHeight - sunY) * renderScale);
      
      const rgb = colorRgb.split(',').map(x => parseInt(x.trim()) / 255);
      gl.uniform3f(glLocations.u_color, rgb[0], rgb[1], rgb[2]);
      gl.uniform1f(glLocations.u_intensity, parseFloat(intensity));
      gl.uniform1f(glLocations.u_range, parseFloat(range));
      gl.uniform1f(glLocations.u_opacity, parseFloat(opacity));

      gl.drawArrays(gl.TRIANGLES, 0, 6);
    }

    function setRenderMode(mode) {
      if (mode === 'webgl') {
        document.body.classList.add('use-webgl');
        renderScaleRow.style.display = 'flex';
        if (!gl) initWebGL();
        resizeWebGL(); // Ensure size is correct immediately
        isWebGLActive = true;
      } else {
        document.body.classList.remove('use-webgl');
        renderScaleRow.style.display = 'none';
        isWebGLActive = false;
      }
      localStorage.setItem('render_mode', mode);
    }

    renderModeSelect.addEventListener('change', (e) => {
      setRenderMode(e.target.value);
    });

    renderScaleSlider.addEventListener('input', (e) => {
      renderScale = parseFloat(e.target.value);
      renderScaleVal.textContent = renderScale.toFixed(2) + 'x';
      resizeWebGL();
      localStorage.setItem('render_scale', renderScale);
    });

    // Init settings
    const savedRenderMode = localStorage.getItem('render_mode') || 'webgl'; // Default to WebGL
    renderModeSelect.value = savedRenderMode;
    setRenderMode(savedRenderMode);

    const savedRenderScale = localStorage.getItem('render_scale');
    if (savedRenderScale) {
      renderScale = parseFloat(savedRenderScale);
      renderScaleSlider.value = renderScale;
      renderScaleVal.textContent = renderScale.toFixed(2) + 'x';
      resizeWebGL();
    }

    window.addEventListener('resize', resizeWebGL);


    let currentX = window.innerWidth / 2;
    let currentY = -100;
    let currentSize = 1000;
    let currentOpacity = 0;
    let lastColorUpdate = 0;
    let cachedSunlightColor = '255, 255, 255';
    let lastFrameTime = 0;

    function updateLight(timestamp) {
      // Use performance.now() for consistent timing across rAF and setTimeout
      const now = performance.now();
      
      // If disabled, stop the loop
      if (isLightDisabled) return;

      let targetInterval = 16; // Default 60fps
      let shouldPauseCss = false;

      if (effectQuality === 'high') {
        targetInterval = 16;
        shouldPauseCss = false;
      } else if (effectQuality === 'balanced') {
        const isInteracting = isMouseInWindow && (now - lastMouseMoveTime < 2000);
        targetInterval = isInteracting ? 33 : 1000;
        shouldPauseCss = !isInteracting;
      } else if (effectQuality === 'low') {
        const isInteracting = isMouseInWindow && (now - lastMouseMoveTime < 2000);
        targetInterval = isInteracting ? 100 : 2000;
        shouldPauseCss = !isInteracting;
      }

      // Toggle CSS animation state
      if (shouldPauseCss) {
        document.body.classList.add('paused');
      } else {
        document.body.classList.remove('paused');
      }

      if (now - lastFrameTime < targetInterval) {
        if (effectQuality === 'high') {
          requestAnimationFrame(updateLight);
        } else {
          setTimeout(() => requestAnimationFrame(updateLight), targetInterval - (now - lastFrameTime));
        }
        return;
      }
      lastFrameTime = now;

      const w = window.innerWidth;
      const h = window.innerHeight;
      
      // 1. Sun Position (Source) - Moves slowly across top
      const date = new Date();
      const hour = date.getHours() + date.getMinutes() / 60 + date.getSeconds() / 3600;
      // Cycle: 6am -> 0.0, 18pm -> 1.0
      const cycleProgress = ((hour - 6 + 24) % 24) / 12; 
      const normalizedProgress = cycleProgress % 1; 
      
      // Sun moves from 20% to 80% width
      let sunX = (0.2 + normalizedProgress * 0.6) * w; 
      let sunY = -150; // Above screen

      // 2. Beam Calculation (Sun -> Mouse)
      // Angle from Sun to Mouse
      const dx = mouseX - sunX;
      const dy = mouseY - sunY;
      let angleRad = Math.atan2(dy, dx);
      let angleDeg = angleRad * (180 / Math.PI);
      
      // CSS conic-gradient 0deg is Top (12 o'clock). atan2 0 is Right (3 o'clock).
      // Correction: +90 degrees.
      let cssAngle = angleDeg + 90;

      // The beam wedge is 30deg wide (0 to 30). Center is 15.
      // We want center to align with cssAngle.
      let beamStart = cssAngle - 15;

      // 3. Opacity Logic (Smooth fade in/out)
      let targetOpacity = isMouseInWindow ? 1 : 0;
      currentOpacity += (targetOpacity - currentOpacity) * 0.1;

      // 4. Color Logic
      let currentRgb;
      if (isAutoColor) {
        if (now - lastColorUpdate > 1000) {
          cachedSunlightColor = getSunlightColor();
          lastColorUpdate = now;
        }
        currentRgb = cachedSunlightColor;
      } else {
        currentRgb = manualColorRgb;
      }

      // 5. Update CSS Variables
      const rootStyle = document.documentElement.style;
      rootStyle.setProperty('--sun-x', `${sunX.toFixed(1)}px`);
      rootStyle.setProperty('--sun-y', `${sunY.toFixed(1)}px`);
      rootStyle.setProperty('--mouse-x', `${mouseX.toFixed(1)}px`);
      rootStyle.setProperty('--mouse-y', `${mouseY.toFixed(1)}px`);
      rootStyle.setProperty('--beam-start', `${beamStart.toFixed(2)}deg`);
      rootStyle.setProperty('--spot-opacity', currentOpacity.toFixed(3));
      rootStyle.setProperty('--beam-opacity', (currentOpacity * 0.4).toFixed(3)); // Beam is subtler
      rootStyle.setProperty('--light-rgb', currentRgb);
      rootStyle.setProperty('--light-size', 'calc(1200px * var(--light-range-scale, 1))'); // Large ambient light
      
      // 6. Render WebGL
      if (isWebGLActive) {
        renderWebGL(now, sunX, sunY, mouseX, mouseY, currentRgb, intensitySlider.value, rangeSlider.value, currentOpacity);
      }

      // Schedule next frame
      if (effectQuality === 'high') {
        requestAnimationFrame(updateLight);
      } else {
        setTimeout(() => requestAnimationFrame(updateLight), targetInterval);
      }
    }
    
    // Load settings after all variables are initialized
    loadSettings();
    
    requestAnimationFrame(updateLight);
  </script>
</body>
</html>


